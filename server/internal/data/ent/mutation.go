// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"faceto-ai/internal/data/ent/auth"
	"faceto-ai/internal/data/ent/authtoken"
	"faceto-ai/internal/data/ent/link"
	"faceto-ai/internal/data/ent/predicate"
	"faceto-ai/internal/data/ent/room"
	"faceto-ai/internal/data/ent/roommessage"
	"faceto-ai/internal/data/ent/roomvod"
	"faceto-ai/internal/data/ent/roomwebhook"
	"faceto-ai/internal/data/ent/servicewebhooklog"
	"faceto-ai/internal/data/schema"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/livekit/protocol/livekit"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuth              = "Auth"
	TypeAuthToken         = "AuthToken"
	TypeLink              = "Link"
	TypeRoom              = "Room"
	TypeRoomMessage       = "RoomMessage"
	TypeRoomVod           = "RoomVod"
	TypeRoomWebhook       = "RoomWebhook"
	TypeServiceWebhookLog = "ServiceWebhookLog"
)

// AuthMutation represents an operation that mutates the Auth nodes in the graph.
type AuthMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	uuid          *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	client_id     *string
	client_secret *string
	grant_scope   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Auth, error)
	predicates    []predicate.Auth
}

var _ ent.Mutation = (*AuthMutation)(nil)

// authOption allows management of the mutation configuration using functional options.
type authOption func(*AuthMutation)

// newAuthMutation creates new mutation for the Auth entity.
func newAuthMutation(c config, op Op, opts ...authOption) *AuthMutation {
	m := &AuthMutation{
		config:        c,
		op:            op,
		typ:           TypeAuth,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthID sets the ID field of the mutation.
func withAuthID(id uint64) authOption {
	return func(m *AuthMutation) {
		var (
			err   error
			once  sync.Once
			value *Auth
		)
		m.oldValue = func(ctx context.Context) (*Auth, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Auth.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuth sets the old Auth of the mutation.
func withAuth(node *Auth) authOption {
	return func(m *AuthMutation) {
		m.oldValue = func(context.Context) (*Auth, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Auth entities.
func (m *AuthMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Auth.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *AuthMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *AuthMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *AuthMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuthMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuthMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuthMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AuthMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AuthMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AuthMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[auth.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AuthMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[auth.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AuthMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, auth.FieldDeletedAt)
}

// SetClientID sets the "client_id" field.
func (m *AuthMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *AuthMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *AuthMutation) ResetClientID() {
	m.client_id = nil
}

// SetClientSecret sets the "client_secret" field.
func (m *AuthMutation) SetClientSecret(s string) {
	m.client_secret = &s
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *AuthMutation) ClientSecret() (r string, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ClearClientSecret clears the value of the "client_secret" field.
func (m *AuthMutation) ClearClientSecret() {
	m.client_secret = nil
	m.clearedFields[auth.FieldClientSecret] = struct{}{}
}

// ClientSecretCleared returns if the "client_secret" field was cleared in this mutation.
func (m *AuthMutation) ClientSecretCleared() bool {
	_, ok := m.clearedFields[auth.FieldClientSecret]
	return ok
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *AuthMutation) ResetClientSecret() {
	m.client_secret = nil
	delete(m.clearedFields, auth.FieldClientSecret)
}

// SetGrantScope sets the "grant_scope" field.
func (m *AuthMutation) SetGrantScope(s string) {
	m.grant_scope = &s
}

// GrantScope returns the value of the "grant_scope" field in the mutation.
func (m *AuthMutation) GrantScope() (r string, exists bool) {
	v := m.grant_scope
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantScope returns the old "grant_scope" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldGrantScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantScope: %w", err)
	}
	return oldValue.GrantScope, nil
}

// ClearGrantScope clears the value of the "grant_scope" field.
func (m *AuthMutation) ClearGrantScope() {
	m.grant_scope = nil
	m.clearedFields[auth.FieldGrantScope] = struct{}{}
}

// GrantScopeCleared returns if the "grant_scope" field was cleared in this mutation.
func (m *AuthMutation) GrantScopeCleared() bool {
	_, ok := m.clearedFields[auth.FieldGrantScope]
	return ok
}

// ResetGrantScope resets all changes to the "grant_scope" field.
func (m *AuthMutation) ResetGrantScope() {
	m.grant_scope = nil
	delete(m.clearedFields, auth.FieldGrantScope)
}

// Where appends a list predicates to the AuthMutation builder.
func (m *AuthMutation) Where(ps ...predicate.Auth) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Auth, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Auth).
func (m *AuthMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uuid != nil {
		fields = append(fields, auth.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, auth.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, auth.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, auth.FieldDeletedAt)
	}
	if m.client_id != nil {
		fields = append(fields, auth.FieldClientID)
	}
	if m.client_secret != nil {
		fields = append(fields, auth.FieldClientSecret)
	}
	if m.grant_scope != nil {
		fields = append(fields, auth.FieldGrantScope)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auth.FieldUUID:
		return m.UUID()
	case auth.FieldCreatedAt:
		return m.CreatedAt()
	case auth.FieldUpdatedAt:
		return m.UpdatedAt()
	case auth.FieldDeletedAt:
		return m.DeletedAt()
	case auth.FieldClientID:
		return m.ClientID()
	case auth.FieldClientSecret:
		return m.ClientSecret()
	case auth.FieldGrantScope:
		return m.GrantScope()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auth.FieldUUID:
		return m.OldUUID(ctx)
	case auth.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case auth.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case auth.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case auth.FieldClientID:
		return m.OldClientID(ctx)
	case auth.FieldClientSecret:
		return m.OldClientSecret(ctx)
	case auth.FieldGrantScope:
		return m.OldGrantScope(ctx)
	}
	return nil, fmt.Errorf("unknown Auth field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auth.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case auth.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case auth.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case auth.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case auth.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case auth.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	case auth.FieldGrantScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantScope(v)
		return nil
	}
	return fmt.Errorf("unknown Auth field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Auth numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auth.FieldDeletedAt) {
		fields = append(fields, auth.FieldDeletedAt)
	}
	if m.FieldCleared(auth.FieldClientSecret) {
		fields = append(fields, auth.FieldClientSecret)
	}
	if m.FieldCleared(auth.FieldGrantScope) {
		fields = append(fields, auth.FieldGrantScope)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthMutation) ClearField(name string) error {
	switch name {
	case auth.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case auth.FieldClientSecret:
		m.ClearClientSecret()
		return nil
	case auth.FieldGrantScope:
		m.ClearGrantScope()
		return nil
	}
	return fmt.Errorf("unknown Auth nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthMutation) ResetField(name string) error {
	switch name {
	case auth.FieldUUID:
		m.ResetUUID()
		return nil
	case auth.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case auth.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case auth.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case auth.FieldClientID:
		m.ResetClientID()
		return nil
	case auth.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	case auth.FieldGrantScope:
		m.ResetGrantScope()
		return nil
	}
	return fmt.Errorf("unknown Auth field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Auth unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Auth edge %s", name)
}

// AuthTokenMutation represents an operation that mutates the AuthToken nodes in the graph.
type AuthTokenMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	uuid          *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	client_id     *string
	access_token  *string
	refresh_token *string
	expires_in    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuthToken, error)
	predicates    []predicate.AuthToken
}

var _ ent.Mutation = (*AuthTokenMutation)(nil)

// authtokenOption allows management of the mutation configuration using functional options.
type authtokenOption func(*AuthTokenMutation)

// newAuthTokenMutation creates new mutation for the AuthToken entity.
func newAuthTokenMutation(c config, op Op, opts ...authtokenOption) *AuthTokenMutation {
	m := &AuthTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthTokenID sets the ID field of the mutation.
func withAuthTokenID(id uint64) authtokenOption {
	return func(m *AuthTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthToken
		)
		m.oldValue = func(ctx context.Context) (*AuthToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthToken sets the old AuthToken of the mutation.
func withAuthToken(node *AuthToken) authtokenOption {
	return func(m *AuthTokenMutation) {
		m.oldValue = func(context.Context) (*AuthToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthToken entities.
func (m *AuthTokenMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthTokenMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthTokenMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *AuthTokenMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *AuthTokenMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *AuthTokenMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuthTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuthTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuthTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AuthTokenMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AuthTokenMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AuthTokenMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[authtoken.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AuthTokenMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[authtoken.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AuthTokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, authtoken.FieldDeletedAt)
}

// SetClientID sets the "client_id" field.
func (m *AuthTokenMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *AuthTokenMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *AuthTokenMutation) ResetClientID() {
	m.client_id = nil
}

// SetAccessToken sets the "access_token" field.
func (m *AuthTokenMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *AuthTokenMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ClearAccessToken clears the value of the "access_token" field.
func (m *AuthTokenMutation) ClearAccessToken() {
	m.access_token = nil
	m.clearedFields[authtoken.FieldAccessToken] = struct{}{}
}

// AccessTokenCleared returns if the "access_token" field was cleared in this mutation.
func (m *AuthTokenMutation) AccessTokenCleared() bool {
	_, ok := m.clearedFields[authtoken.FieldAccessToken]
	return ok
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *AuthTokenMutation) ResetAccessToken() {
	m.access_token = nil
	delete(m.clearedFields, authtoken.FieldAccessToken)
}

// SetRefreshToken sets the "refresh_token" field.
func (m *AuthTokenMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *AuthTokenMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ClearRefreshToken clears the value of the "refresh_token" field.
func (m *AuthTokenMutation) ClearRefreshToken() {
	m.refresh_token = nil
	m.clearedFields[authtoken.FieldRefreshToken] = struct{}{}
}

// RefreshTokenCleared returns if the "refresh_token" field was cleared in this mutation.
func (m *AuthTokenMutation) RefreshTokenCleared() bool {
	_, ok := m.clearedFields[authtoken.FieldRefreshToken]
	return ok
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *AuthTokenMutation) ResetRefreshToken() {
	m.refresh_token = nil
	delete(m.clearedFields, authtoken.FieldRefreshToken)
}

// SetExpiresIn sets the "expires_in" field.
func (m *AuthTokenMutation) SetExpiresIn(t time.Time) {
	m.expires_in = &t
}

// ExpiresIn returns the value of the "expires_in" field in the mutation.
func (m *AuthTokenMutation) ExpiresIn() (r time.Time, exists bool) {
	v := m.expires_in
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresIn returns the old "expires_in" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldExpiresIn(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresIn: %w", err)
	}
	return oldValue.ExpiresIn, nil
}

// ClearExpiresIn clears the value of the "expires_in" field.
func (m *AuthTokenMutation) ClearExpiresIn() {
	m.expires_in = nil
	m.clearedFields[authtoken.FieldExpiresIn] = struct{}{}
}

// ExpiresInCleared returns if the "expires_in" field was cleared in this mutation.
func (m *AuthTokenMutation) ExpiresInCleared() bool {
	_, ok := m.clearedFields[authtoken.FieldExpiresIn]
	return ok
}

// ResetExpiresIn resets all changes to the "expires_in" field.
func (m *AuthTokenMutation) ResetExpiresIn() {
	m.expires_in = nil
	delete(m.clearedFields, authtoken.FieldExpiresIn)
}

// Where appends a list predicates to the AuthTokenMutation builder.
func (m *AuthTokenMutation) Where(ps ...predicate.AuthToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthToken).
func (m *AuthTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthTokenMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.uuid != nil {
		fields = append(fields, authtoken.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, authtoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, authtoken.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, authtoken.FieldDeletedAt)
	}
	if m.client_id != nil {
		fields = append(fields, authtoken.FieldClientID)
	}
	if m.access_token != nil {
		fields = append(fields, authtoken.FieldAccessToken)
	}
	if m.refresh_token != nil {
		fields = append(fields, authtoken.FieldRefreshToken)
	}
	if m.expires_in != nil {
		fields = append(fields, authtoken.FieldExpiresIn)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authtoken.FieldUUID:
		return m.UUID()
	case authtoken.FieldCreatedAt:
		return m.CreatedAt()
	case authtoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case authtoken.FieldDeletedAt:
		return m.DeletedAt()
	case authtoken.FieldClientID:
		return m.ClientID()
	case authtoken.FieldAccessToken:
		return m.AccessToken()
	case authtoken.FieldRefreshToken:
		return m.RefreshToken()
	case authtoken.FieldExpiresIn:
		return m.ExpiresIn()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authtoken.FieldUUID:
		return m.OldUUID(ctx)
	case authtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case authtoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case authtoken.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case authtoken.FieldClientID:
		return m.OldClientID(ctx)
	case authtoken.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case authtoken.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case authtoken.FieldExpiresIn:
		return m.OldExpiresIn(ctx)
	}
	return nil, fmt.Errorf("unknown AuthToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authtoken.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case authtoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case authtoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case authtoken.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case authtoken.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case authtoken.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case authtoken.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case authtoken.FieldExpiresIn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresIn(v)
		return nil
	}
	return fmt.Errorf("unknown AuthToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(authtoken.FieldDeletedAt) {
		fields = append(fields, authtoken.FieldDeletedAt)
	}
	if m.FieldCleared(authtoken.FieldAccessToken) {
		fields = append(fields, authtoken.FieldAccessToken)
	}
	if m.FieldCleared(authtoken.FieldRefreshToken) {
		fields = append(fields, authtoken.FieldRefreshToken)
	}
	if m.FieldCleared(authtoken.FieldExpiresIn) {
		fields = append(fields, authtoken.FieldExpiresIn)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthTokenMutation) ClearField(name string) error {
	switch name {
	case authtoken.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case authtoken.FieldAccessToken:
		m.ClearAccessToken()
		return nil
	case authtoken.FieldRefreshToken:
		m.ClearRefreshToken()
		return nil
	case authtoken.FieldExpiresIn:
		m.ClearExpiresIn()
		return nil
	}
	return fmt.Errorf("unknown AuthToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthTokenMutation) ResetField(name string) error {
	switch name {
	case authtoken.FieldUUID:
		m.ResetUUID()
		return nil
	case authtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case authtoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case authtoken.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case authtoken.FieldClientID:
		m.ResetClientID()
		return nil
	case authtoken.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case authtoken.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case authtoken.FieldExpiresIn:
		m.ResetExpiresIn()
		return nil
	}
	return fmt.Errorf("unknown AuthToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthTokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthTokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthTokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthTokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthToken edge %s", name)
}

// LinkMutation represents an operation that mutates the Link nodes in the graph.
type LinkMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	uuid          *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	room_name     *string
	link          *string
	chat_api      *string
	chat_api_key  *string
	token         *string
	_config       **schema.RoomConfig
	webhook       **schema.Webhook
	prompt        **schema.Prompt
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Link, error)
	predicates    []predicate.Link
}

var _ ent.Mutation = (*LinkMutation)(nil)

// linkOption allows management of the mutation configuration using functional options.
type linkOption func(*LinkMutation)

// newLinkMutation creates new mutation for the Link entity.
func newLinkMutation(c config, op Op, opts ...linkOption) *LinkMutation {
	m := &LinkMutation{
		config:        c,
		op:            op,
		typ:           TypeLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLinkID sets the ID field of the mutation.
func withLinkID(id uint64) linkOption {
	return func(m *LinkMutation) {
		var (
			err   error
			once  sync.Once
			value *Link
		)
		m.oldValue = func(ctx context.Context) (*Link, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Link.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLink sets the old Link of the mutation.
func withLink(node *Link) linkOption {
	return func(m *LinkMutation) {
		m.oldValue = func(context.Context) (*Link, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Link entities.
func (m *LinkMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LinkMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LinkMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Link.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *LinkMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *LinkMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *LinkMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LinkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LinkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LinkMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LinkMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LinkMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *LinkMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[link.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *LinkMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[link.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LinkMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, link.FieldDeletedAt)
}

// SetRoomName sets the "room_name" field.
func (m *LinkMutation) SetRoomName(s string) {
	m.room_name = &s
}

// RoomName returns the value of the "room_name" field in the mutation.
func (m *LinkMutation) RoomName() (r string, exists bool) {
	v := m.room_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomName returns the old "room_name" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldRoomName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoomName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoomName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomName: %w", err)
	}
	return oldValue.RoomName, nil
}

// ResetRoomName resets all changes to the "room_name" field.
func (m *LinkMutation) ResetRoomName() {
	m.room_name = nil
}

// SetLink sets the "link" field.
func (m *LinkMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *LinkMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "link" field.
func (m *LinkMutation) ClearLink() {
	m.link = nil
	m.clearedFields[link.FieldLink] = struct{}{}
}

// LinkCleared returns if the "link" field was cleared in this mutation.
func (m *LinkMutation) LinkCleared() bool {
	_, ok := m.clearedFields[link.FieldLink]
	return ok
}

// ResetLink resets all changes to the "link" field.
func (m *LinkMutation) ResetLink() {
	m.link = nil
	delete(m.clearedFields, link.FieldLink)
}

// SetChatAPI sets the "chat_api" field.
func (m *LinkMutation) SetChatAPI(s string) {
	m.chat_api = &s
}

// ChatAPI returns the value of the "chat_api" field in the mutation.
func (m *LinkMutation) ChatAPI() (r string, exists bool) {
	v := m.chat_api
	if v == nil {
		return
	}
	return *v, true
}

// OldChatAPI returns the old "chat_api" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldChatAPI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatAPI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatAPI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatAPI: %w", err)
	}
	return oldValue.ChatAPI, nil
}

// ClearChatAPI clears the value of the "chat_api" field.
func (m *LinkMutation) ClearChatAPI() {
	m.chat_api = nil
	m.clearedFields[link.FieldChatAPI] = struct{}{}
}

// ChatAPICleared returns if the "chat_api" field was cleared in this mutation.
func (m *LinkMutation) ChatAPICleared() bool {
	_, ok := m.clearedFields[link.FieldChatAPI]
	return ok
}

// ResetChatAPI resets all changes to the "chat_api" field.
func (m *LinkMutation) ResetChatAPI() {
	m.chat_api = nil
	delete(m.clearedFields, link.FieldChatAPI)
}

// SetChatAPIKey sets the "chat_api_key" field.
func (m *LinkMutation) SetChatAPIKey(s string) {
	m.chat_api_key = &s
}

// ChatAPIKey returns the value of the "chat_api_key" field in the mutation.
func (m *LinkMutation) ChatAPIKey() (r string, exists bool) {
	v := m.chat_api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldChatAPIKey returns the old "chat_api_key" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldChatAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatAPIKey: %w", err)
	}
	return oldValue.ChatAPIKey, nil
}

// ClearChatAPIKey clears the value of the "chat_api_key" field.
func (m *LinkMutation) ClearChatAPIKey() {
	m.chat_api_key = nil
	m.clearedFields[link.FieldChatAPIKey] = struct{}{}
}

// ChatAPIKeyCleared returns if the "chat_api_key" field was cleared in this mutation.
func (m *LinkMutation) ChatAPIKeyCleared() bool {
	_, ok := m.clearedFields[link.FieldChatAPIKey]
	return ok
}

// ResetChatAPIKey resets all changes to the "chat_api_key" field.
func (m *LinkMutation) ResetChatAPIKey() {
	m.chat_api_key = nil
	delete(m.clearedFields, link.FieldChatAPIKey)
}

// SetToken sets the "token" field.
func (m *LinkMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *LinkMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ClearToken clears the value of the "token" field.
func (m *LinkMutation) ClearToken() {
	m.token = nil
	m.clearedFields[link.FieldToken] = struct{}{}
}

// TokenCleared returns if the "token" field was cleared in this mutation.
func (m *LinkMutation) TokenCleared() bool {
	_, ok := m.clearedFields[link.FieldToken]
	return ok
}

// ResetToken resets all changes to the "token" field.
func (m *LinkMutation) ResetToken() {
	m.token = nil
	delete(m.clearedFields, link.FieldToken)
}

// SetConfig sets the "config" field.
func (m *LinkMutation) SetConfig(sc *schema.RoomConfig) {
	m._config = &sc
}

// Config returns the value of the "config" field in the mutation.
func (m *LinkMutation) Config() (r *schema.RoomConfig, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldConfig(ctx context.Context) (v *schema.RoomConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *LinkMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[link.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *LinkMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[link.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *LinkMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, link.FieldConfig)
}

// SetWebhook sets the "webhook" field.
func (m *LinkMutation) SetWebhook(s *schema.Webhook) {
	m.webhook = &s
}

// Webhook returns the value of the "webhook" field in the mutation.
func (m *LinkMutation) Webhook() (r *schema.Webhook, exists bool) {
	v := m.webhook
	if v == nil {
		return
	}
	return *v, true
}

// OldWebhook returns the old "webhook" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldWebhook(ctx context.Context) (v *schema.Webhook, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebhook is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebhook requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebhook: %w", err)
	}
	return oldValue.Webhook, nil
}

// ClearWebhook clears the value of the "webhook" field.
func (m *LinkMutation) ClearWebhook() {
	m.webhook = nil
	m.clearedFields[link.FieldWebhook] = struct{}{}
}

// WebhookCleared returns if the "webhook" field was cleared in this mutation.
func (m *LinkMutation) WebhookCleared() bool {
	_, ok := m.clearedFields[link.FieldWebhook]
	return ok
}

// ResetWebhook resets all changes to the "webhook" field.
func (m *LinkMutation) ResetWebhook() {
	m.webhook = nil
	delete(m.clearedFields, link.FieldWebhook)
}

// SetPrompt sets the "prompt" field.
func (m *LinkMutation) SetPrompt(s *schema.Prompt) {
	m.prompt = &s
}

// Prompt returns the value of the "prompt" field in the mutation.
func (m *LinkMutation) Prompt() (r *schema.Prompt, exists bool) {
	v := m.prompt
	if v == nil {
		return
	}
	return *v, true
}

// OldPrompt returns the old "prompt" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldPrompt(ctx context.Context) (v *schema.Prompt, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrompt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrompt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrompt: %w", err)
	}
	return oldValue.Prompt, nil
}

// ClearPrompt clears the value of the "prompt" field.
func (m *LinkMutation) ClearPrompt() {
	m.prompt = nil
	m.clearedFields[link.FieldPrompt] = struct{}{}
}

// PromptCleared returns if the "prompt" field was cleared in this mutation.
func (m *LinkMutation) PromptCleared() bool {
	_, ok := m.clearedFields[link.FieldPrompt]
	return ok
}

// ResetPrompt resets all changes to the "prompt" field.
func (m *LinkMutation) ResetPrompt() {
	m.prompt = nil
	delete(m.clearedFields, link.FieldPrompt)
}

// Where appends a list predicates to the LinkMutation builder.
func (m *LinkMutation) Where(ps ...predicate.Link) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Link, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Link).
func (m *LinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LinkMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.uuid != nil {
		fields = append(fields, link.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, link.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, link.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, link.FieldDeletedAt)
	}
	if m.room_name != nil {
		fields = append(fields, link.FieldRoomName)
	}
	if m.link != nil {
		fields = append(fields, link.FieldLink)
	}
	if m.chat_api != nil {
		fields = append(fields, link.FieldChatAPI)
	}
	if m.chat_api_key != nil {
		fields = append(fields, link.FieldChatAPIKey)
	}
	if m.token != nil {
		fields = append(fields, link.FieldToken)
	}
	if m._config != nil {
		fields = append(fields, link.FieldConfig)
	}
	if m.webhook != nil {
		fields = append(fields, link.FieldWebhook)
	}
	if m.prompt != nil {
		fields = append(fields, link.FieldPrompt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case link.FieldUUID:
		return m.UUID()
	case link.FieldCreatedAt:
		return m.CreatedAt()
	case link.FieldUpdatedAt:
		return m.UpdatedAt()
	case link.FieldDeletedAt:
		return m.DeletedAt()
	case link.FieldRoomName:
		return m.RoomName()
	case link.FieldLink:
		return m.Link()
	case link.FieldChatAPI:
		return m.ChatAPI()
	case link.FieldChatAPIKey:
		return m.ChatAPIKey()
	case link.FieldToken:
		return m.Token()
	case link.FieldConfig:
		return m.Config()
	case link.FieldWebhook:
		return m.Webhook()
	case link.FieldPrompt:
		return m.Prompt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case link.FieldUUID:
		return m.OldUUID(ctx)
	case link.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case link.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case link.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case link.FieldRoomName:
		return m.OldRoomName(ctx)
	case link.FieldLink:
		return m.OldLink(ctx)
	case link.FieldChatAPI:
		return m.OldChatAPI(ctx)
	case link.FieldChatAPIKey:
		return m.OldChatAPIKey(ctx)
	case link.FieldToken:
		return m.OldToken(ctx)
	case link.FieldConfig:
		return m.OldConfig(ctx)
	case link.FieldWebhook:
		return m.OldWebhook(ctx)
	case link.FieldPrompt:
		return m.OldPrompt(ctx)
	}
	return nil, fmt.Errorf("unknown Link field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case link.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case link.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case link.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case link.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case link.FieldRoomName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomName(v)
		return nil
	case link.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case link.FieldChatAPI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatAPI(v)
		return nil
	case link.FieldChatAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatAPIKey(v)
		return nil
	case link.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case link.FieldConfig:
		v, ok := value.(*schema.RoomConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case link.FieldWebhook:
		v, ok := value.(*schema.Webhook)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebhook(v)
		return nil
	case link.FieldPrompt:
		v, ok := value.(*schema.Prompt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrompt(v)
		return nil
	}
	return fmt.Errorf("unknown Link field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LinkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LinkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Link numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(link.FieldDeletedAt) {
		fields = append(fields, link.FieldDeletedAt)
	}
	if m.FieldCleared(link.FieldLink) {
		fields = append(fields, link.FieldLink)
	}
	if m.FieldCleared(link.FieldChatAPI) {
		fields = append(fields, link.FieldChatAPI)
	}
	if m.FieldCleared(link.FieldChatAPIKey) {
		fields = append(fields, link.FieldChatAPIKey)
	}
	if m.FieldCleared(link.FieldToken) {
		fields = append(fields, link.FieldToken)
	}
	if m.FieldCleared(link.FieldConfig) {
		fields = append(fields, link.FieldConfig)
	}
	if m.FieldCleared(link.FieldWebhook) {
		fields = append(fields, link.FieldWebhook)
	}
	if m.FieldCleared(link.FieldPrompt) {
		fields = append(fields, link.FieldPrompt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LinkMutation) ClearField(name string) error {
	switch name {
	case link.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case link.FieldLink:
		m.ClearLink()
		return nil
	case link.FieldChatAPI:
		m.ClearChatAPI()
		return nil
	case link.FieldChatAPIKey:
		m.ClearChatAPIKey()
		return nil
	case link.FieldToken:
		m.ClearToken()
		return nil
	case link.FieldConfig:
		m.ClearConfig()
		return nil
	case link.FieldWebhook:
		m.ClearWebhook()
		return nil
	case link.FieldPrompt:
		m.ClearPrompt()
		return nil
	}
	return fmt.Errorf("unknown Link nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LinkMutation) ResetField(name string) error {
	switch name {
	case link.FieldUUID:
		m.ResetUUID()
		return nil
	case link.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case link.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case link.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case link.FieldRoomName:
		m.ResetRoomName()
		return nil
	case link.FieldLink:
		m.ResetLink()
		return nil
	case link.FieldChatAPI:
		m.ResetChatAPI()
		return nil
	case link.FieldChatAPIKey:
		m.ResetChatAPIKey()
		return nil
	case link.FieldToken:
		m.ResetToken()
		return nil
	case link.FieldConfig:
		m.ResetConfig()
		return nil
	case link.FieldWebhook:
		m.ResetWebhook()
		return nil
	case link.FieldPrompt:
		m.ResetPrompt()
		return nil
	}
	return fmt.Errorf("unknown Link field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LinkMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LinkMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LinkMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Link unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LinkMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Link edge %s", name)
}

// RoomMutation represents an operation that mutates the Room nodes in the graph.
type RoomMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	uuid          *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	sid           *string
	status        *uint8
	addstatus     *int8
	start_time    *time.Time
	left_time     *time.Time
	end_time      *time.Time
	vod_status    *uint8
	addvod_status *int8
	metadata      **schema.Metadata
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Room, error)
	predicates    []predicate.Room
}

var _ ent.Mutation = (*RoomMutation)(nil)

// roomOption allows management of the mutation configuration using functional options.
type roomOption func(*RoomMutation)

// newRoomMutation creates new mutation for the Room entity.
func newRoomMutation(c config, op Op, opts ...roomOption) *RoomMutation {
	m := &RoomMutation{
		config:        c,
		op:            op,
		typ:           TypeRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomID sets the ID field of the mutation.
func withRoomID(id uint64) roomOption {
	return func(m *RoomMutation) {
		var (
			err   error
			once  sync.Once
			value *Room
		)
		m.oldValue = func(ctx context.Context) (*Room, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Room.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoom sets the old Room of the mutation.
func withRoom(node *Room) roomOption {
	return func(m *RoomMutation) {
		m.oldValue = func(context.Context) (*Room, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Room entities.
func (m *RoomMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoomMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoomMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Room.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *RoomMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *RoomMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *RoomMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RoomMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoomMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoomMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoomMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoomMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoomMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoomMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoomMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RoomMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[room.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RoomMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[room.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoomMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, room.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *RoomMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoomMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoomMutation) ResetName() {
	m.name = nil
}

// SetSid sets the "sid" field.
func (m *RoomMutation) SetSid(s string) {
	m.sid = &s
}

// Sid returns the value of the "sid" field in the mutation.
func (m *RoomMutation) Sid() (r string, exists bool) {
	v := m.sid
	if v == nil {
		return
	}
	return *v, true
}

// OldSid returns the old "sid" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldSid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSid: %w", err)
	}
	return oldValue.Sid, nil
}

// ResetSid resets all changes to the "sid" field.
func (m *RoomMutation) ResetSid() {
	m.sid = nil
}

// SetStatus sets the "status" field.
func (m *RoomMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RoomMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *RoomMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RoomMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *RoomMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetStartTime sets the "start_time" field.
func (m *RoomMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *RoomMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *RoomMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[room.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *RoomMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[room.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *RoomMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, room.FieldStartTime)
}

// SetLeftTime sets the "left_time" field.
func (m *RoomMutation) SetLeftTime(t time.Time) {
	m.left_time = &t
}

// LeftTime returns the value of the "left_time" field in the mutation.
func (m *RoomMutation) LeftTime() (r time.Time, exists bool) {
	v := m.left_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLeftTime returns the old "left_time" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldLeftTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeftTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeftTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeftTime: %w", err)
	}
	return oldValue.LeftTime, nil
}

// ClearLeftTime clears the value of the "left_time" field.
func (m *RoomMutation) ClearLeftTime() {
	m.left_time = nil
	m.clearedFields[room.FieldLeftTime] = struct{}{}
}

// LeftTimeCleared returns if the "left_time" field was cleared in this mutation.
func (m *RoomMutation) LeftTimeCleared() bool {
	_, ok := m.clearedFields[room.FieldLeftTime]
	return ok
}

// ResetLeftTime resets all changes to the "left_time" field.
func (m *RoomMutation) ResetLeftTime() {
	m.left_time = nil
	delete(m.clearedFields, room.FieldLeftTime)
}

// SetEndTime sets the "end_time" field.
func (m *RoomMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *RoomMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *RoomMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[room.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *RoomMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[room.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *RoomMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, room.FieldEndTime)
}

// SetVodStatus sets the "vod_status" field.
func (m *RoomMutation) SetVodStatus(u uint8) {
	m.vod_status = &u
	m.addvod_status = nil
}

// VodStatus returns the value of the "vod_status" field in the mutation.
func (m *RoomMutation) VodStatus() (r uint8, exists bool) {
	v := m.vod_status
	if v == nil {
		return
	}
	return *v, true
}

// OldVodStatus returns the old "vod_status" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldVodStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVodStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVodStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVodStatus: %w", err)
	}
	return oldValue.VodStatus, nil
}

// AddVodStatus adds u to the "vod_status" field.
func (m *RoomMutation) AddVodStatus(u int8) {
	if m.addvod_status != nil {
		*m.addvod_status += u
	} else {
		m.addvod_status = &u
	}
}

// AddedVodStatus returns the value that was added to the "vod_status" field in this mutation.
func (m *RoomMutation) AddedVodStatus() (r int8, exists bool) {
	v := m.addvod_status
	if v == nil {
		return
	}
	return *v, true
}

// ClearVodStatus clears the value of the "vod_status" field.
func (m *RoomMutation) ClearVodStatus() {
	m.vod_status = nil
	m.addvod_status = nil
	m.clearedFields[room.FieldVodStatus] = struct{}{}
}

// VodStatusCleared returns if the "vod_status" field was cleared in this mutation.
func (m *RoomMutation) VodStatusCleared() bool {
	_, ok := m.clearedFields[room.FieldVodStatus]
	return ok
}

// ResetVodStatus resets all changes to the "vod_status" field.
func (m *RoomMutation) ResetVodStatus() {
	m.vod_status = nil
	m.addvod_status = nil
	delete(m.clearedFields, room.FieldVodStatus)
}

// SetMetadata sets the "metadata" field.
func (m *RoomMutation) SetMetadata(s *schema.Metadata) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *RoomMutation) Metadata() (r *schema.Metadata, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldMetadata(ctx context.Context) (v *schema.Metadata, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *RoomMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[room.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *RoomMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[room.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *RoomMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, room.FieldMetadata)
}

// Where appends a list predicates to the RoomMutation builder.
func (m *RoomMutation) Where(ps ...predicate.Room) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoomMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoomMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Room, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoomMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoomMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Room).
func (m *RoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoomMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.uuid != nil {
		fields = append(fields, room.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, room.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, room.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, room.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, room.FieldName)
	}
	if m.sid != nil {
		fields = append(fields, room.FieldSid)
	}
	if m.status != nil {
		fields = append(fields, room.FieldStatus)
	}
	if m.start_time != nil {
		fields = append(fields, room.FieldStartTime)
	}
	if m.left_time != nil {
		fields = append(fields, room.FieldLeftTime)
	}
	if m.end_time != nil {
		fields = append(fields, room.FieldEndTime)
	}
	if m.vod_status != nil {
		fields = append(fields, room.FieldVodStatus)
	}
	if m.metadata != nil {
		fields = append(fields, room.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case room.FieldUUID:
		return m.UUID()
	case room.FieldCreatedAt:
		return m.CreatedAt()
	case room.FieldUpdatedAt:
		return m.UpdatedAt()
	case room.FieldDeletedAt:
		return m.DeletedAt()
	case room.FieldName:
		return m.Name()
	case room.FieldSid:
		return m.Sid()
	case room.FieldStatus:
		return m.Status()
	case room.FieldStartTime:
		return m.StartTime()
	case room.FieldLeftTime:
		return m.LeftTime()
	case room.FieldEndTime:
		return m.EndTime()
	case room.FieldVodStatus:
		return m.VodStatus()
	case room.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case room.FieldUUID:
		return m.OldUUID(ctx)
	case room.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case room.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case room.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case room.FieldName:
		return m.OldName(ctx)
	case room.FieldSid:
		return m.OldSid(ctx)
	case room.FieldStatus:
		return m.OldStatus(ctx)
	case room.FieldStartTime:
		return m.OldStartTime(ctx)
	case room.FieldLeftTime:
		return m.OldLeftTime(ctx)
	case room.FieldEndTime:
		return m.OldEndTime(ctx)
	case room.FieldVodStatus:
		return m.OldVodStatus(ctx)
	case room.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Room field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case room.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case room.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case room.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case room.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case room.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case room.FieldSid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSid(v)
		return nil
	case room.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case room.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case room.FieldLeftTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeftTime(v)
		return nil
	case room.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case room.FieldVodStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVodStatus(v)
		return nil
	case room.FieldMetadata:
		v, ok := value.(*schema.Metadata)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoomMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, room.FieldStatus)
	}
	if m.addvod_status != nil {
		fields = append(fields, room.FieldVodStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoomMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case room.FieldStatus:
		return m.AddedStatus()
	case room.FieldVodStatus:
		return m.AddedVodStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	case room.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case room.FieldVodStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVodStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Room numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoomMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(room.FieldDeletedAt) {
		fields = append(fields, room.FieldDeletedAt)
	}
	if m.FieldCleared(room.FieldStartTime) {
		fields = append(fields, room.FieldStartTime)
	}
	if m.FieldCleared(room.FieldLeftTime) {
		fields = append(fields, room.FieldLeftTime)
	}
	if m.FieldCleared(room.FieldEndTime) {
		fields = append(fields, room.FieldEndTime)
	}
	if m.FieldCleared(room.FieldVodStatus) {
		fields = append(fields, room.FieldVodStatus)
	}
	if m.FieldCleared(room.FieldMetadata) {
		fields = append(fields, room.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomMutation) ClearField(name string) error {
	switch name {
	case room.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case room.FieldStartTime:
		m.ClearStartTime()
		return nil
	case room.FieldLeftTime:
		m.ClearLeftTime()
		return nil
	case room.FieldEndTime:
		m.ClearEndTime()
		return nil
	case room.FieldVodStatus:
		m.ClearVodStatus()
		return nil
	case room.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Room nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoomMutation) ResetField(name string) error {
	switch name {
	case room.FieldUUID:
		m.ResetUUID()
		return nil
	case room.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case room.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case room.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case room.FieldName:
		m.ResetName()
		return nil
	case room.FieldSid:
		m.ResetSid()
		return nil
	case room.FieldStatus:
		m.ResetStatus()
		return nil
	case room.FieldStartTime:
		m.ResetStartTime()
		return nil
	case room.FieldLeftTime:
		m.ResetLeftTime()
		return nil
	case room.FieldEndTime:
		m.ResetEndTime()
		return nil
	case room.FieldVodStatus:
		m.ResetVodStatus()
		return nil
	case room.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoomMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoomMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoomMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoomMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Room unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoomMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Room edge %s", name)
}

// RoomMessageMutation represents an operation that mutates the RoomMessage nodes in the graph.
type RoomMessageMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	uuid             *string
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	sid              *string
	participant_sid  *string
	participant_name *string
	_type            *uint32
	add_type         *int32
	is_reply         *uint32
	addis_reply      *int32
	reply_id         *uint64
	addreply_id      *int64
	event_time       *time.Time
	text             *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*RoomMessage, error)
	predicates       []predicate.RoomMessage
}

var _ ent.Mutation = (*RoomMessageMutation)(nil)

// roommessageOption allows management of the mutation configuration using functional options.
type roommessageOption func(*RoomMessageMutation)

// newRoomMessageMutation creates new mutation for the RoomMessage entity.
func newRoomMessageMutation(c config, op Op, opts ...roommessageOption) *RoomMessageMutation {
	m := &RoomMessageMutation{
		config:        c,
		op:            op,
		typ:           TypeRoomMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomMessageID sets the ID field of the mutation.
func withRoomMessageID(id uint64) roommessageOption {
	return func(m *RoomMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *RoomMessage
		)
		m.oldValue = func(ctx context.Context) (*RoomMessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoomMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoomMessage sets the old RoomMessage of the mutation.
func withRoomMessage(node *RoomMessage) roommessageOption {
	return func(m *RoomMessageMutation) {
		m.oldValue = func(context.Context) (*RoomMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RoomMessage entities.
func (m *RoomMessageMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoomMessageMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoomMessageMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RoomMessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *RoomMessageMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *RoomMessageMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the RoomMessage entity.
// If the RoomMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMessageMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *RoomMessageMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RoomMessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoomMessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RoomMessage entity.
// If the RoomMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoomMessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoomMessageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoomMessageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RoomMessage entity.
// If the RoomMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMessageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoomMessageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoomMessageMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoomMessageMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RoomMessage entity.
// If the RoomMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMessageMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RoomMessageMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[roommessage.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RoomMessageMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[roommessage.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoomMessageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, roommessage.FieldDeletedAt)
}

// SetSid sets the "sid" field.
func (m *RoomMessageMutation) SetSid(s string) {
	m.sid = &s
}

// Sid returns the value of the "sid" field in the mutation.
func (m *RoomMessageMutation) Sid() (r string, exists bool) {
	v := m.sid
	if v == nil {
		return
	}
	return *v, true
}

// OldSid returns the old "sid" field's value of the RoomMessage entity.
// If the RoomMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMessageMutation) OldSid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSid: %w", err)
	}
	return oldValue.Sid, nil
}

// ResetSid resets all changes to the "sid" field.
func (m *RoomMessageMutation) ResetSid() {
	m.sid = nil
}

// SetParticipantSid sets the "participant_sid" field.
func (m *RoomMessageMutation) SetParticipantSid(s string) {
	m.participant_sid = &s
}

// ParticipantSid returns the value of the "participant_sid" field in the mutation.
func (m *RoomMessageMutation) ParticipantSid() (r string, exists bool) {
	v := m.participant_sid
	if v == nil {
		return
	}
	return *v, true
}

// OldParticipantSid returns the old "participant_sid" field's value of the RoomMessage entity.
// If the RoomMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMessageMutation) OldParticipantSid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParticipantSid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParticipantSid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParticipantSid: %w", err)
	}
	return oldValue.ParticipantSid, nil
}

// ResetParticipantSid resets all changes to the "participant_sid" field.
func (m *RoomMessageMutation) ResetParticipantSid() {
	m.participant_sid = nil
}

// SetParticipantName sets the "participant_name" field.
func (m *RoomMessageMutation) SetParticipantName(s string) {
	m.participant_name = &s
}

// ParticipantName returns the value of the "participant_name" field in the mutation.
func (m *RoomMessageMutation) ParticipantName() (r string, exists bool) {
	v := m.participant_name
	if v == nil {
		return
	}
	return *v, true
}

// OldParticipantName returns the old "participant_name" field's value of the RoomMessage entity.
// If the RoomMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMessageMutation) OldParticipantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParticipantName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParticipantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParticipantName: %w", err)
	}
	return oldValue.ParticipantName, nil
}

// ResetParticipantName resets all changes to the "participant_name" field.
func (m *RoomMessageMutation) ResetParticipantName() {
	m.participant_name = nil
}

// SetType sets the "type" field.
func (m *RoomMessageMutation) SetType(u uint32) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *RoomMessageMutation) GetType() (r uint32, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the RoomMessage entity.
// If the RoomMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMessageMutation) OldType(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *RoomMessageMutation) AddType(u int32) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *RoomMessageMutation) AddedType() (r int32, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearType clears the value of the "type" field.
func (m *RoomMessageMutation) ClearType() {
	m._type = nil
	m.add_type = nil
	m.clearedFields[roommessage.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *RoomMessageMutation) TypeCleared() bool {
	_, ok := m.clearedFields[roommessage.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *RoomMessageMutation) ResetType() {
	m._type = nil
	m.add_type = nil
	delete(m.clearedFields, roommessage.FieldType)
}

// SetIsReply sets the "is_reply" field.
func (m *RoomMessageMutation) SetIsReply(u uint32) {
	m.is_reply = &u
	m.addis_reply = nil
}

// IsReply returns the value of the "is_reply" field in the mutation.
func (m *RoomMessageMutation) IsReply() (r uint32, exists bool) {
	v := m.is_reply
	if v == nil {
		return
	}
	return *v, true
}

// OldIsReply returns the old "is_reply" field's value of the RoomMessage entity.
// If the RoomMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMessageMutation) OldIsReply(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsReply is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsReply requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsReply: %w", err)
	}
	return oldValue.IsReply, nil
}

// AddIsReply adds u to the "is_reply" field.
func (m *RoomMessageMutation) AddIsReply(u int32) {
	if m.addis_reply != nil {
		*m.addis_reply += u
	} else {
		m.addis_reply = &u
	}
}

// AddedIsReply returns the value that was added to the "is_reply" field in this mutation.
func (m *RoomMessageMutation) AddedIsReply() (r int32, exists bool) {
	v := m.addis_reply
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsReply resets all changes to the "is_reply" field.
func (m *RoomMessageMutation) ResetIsReply() {
	m.is_reply = nil
	m.addis_reply = nil
}

// SetReplyID sets the "reply_id" field.
func (m *RoomMessageMutation) SetReplyID(u uint64) {
	m.reply_id = &u
	m.addreply_id = nil
}

// ReplyID returns the value of the "reply_id" field in the mutation.
func (m *RoomMessageMutation) ReplyID() (r uint64, exists bool) {
	v := m.reply_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyID returns the old "reply_id" field's value of the RoomMessage entity.
// If the RoomMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMessageMutation) OldReplyID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyID: %w", err)
	}
	return oldValue.ReplyID, nil
}

// AddReplyID adds u to the "reply_id" field.
func (m *RoomMessageMutation) AddReplyID(u int64) {
	if m.addreply_id != nil {
		*m.addreply_id += u
	} else {
		m.addreply_id = &u
	}
}

// AddedReplyID returns the value that was added to the "reply_id" field in this mutation.
func (m *RoomMessageMutation) AddedReplyID() (r int64, exists bool) {
	v := m.addreply_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearReplyID clears the value of the "reply_id" field.
func (m *RoomMessageMutation) ClearReplyID() {
	m.reply_id = nil
	m.addreply_id = nil
	m.clearedFields[roommessage.FieldReplyID] = struct{}{}
}

// ReplyIDCleared returns if the "reply_id" field was cleared in this mutation.
func (m *RoomMessageMutation) ReplyIDCleared() bool {
	_, ok := m.clearedFields[roommessage.FieldReplyID]
	return ok
}

// ResetReplyID resets all changes to the "reply_id" field.
func (m *RoomMessageMutation) ResetReplyID() {
	m.reply_id = nil
	m.addreply_id = nil
	delete(m.clearedFields, roommessage.FieldReplyID)
}

// SetEventTime sets the "event_time" field.
func (m *RoomMessageMutation) SetEventTime(t time.Time) {
	m.event_time = &t
}

// EventTime returns the value of the "event_time" field in the mutation.
func (m *RoomMessageMutation) EventTime() (r time.Time, exists bool) {
	v := m.event_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEventTime returns the old "event_time" field's value of the RoomMessage entity.
// If the RoomMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMessageMutation) OldEventTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventTime: %w", err)
	}
	return oldValue.EventTime, nil
}

// ClearEventTime clears the value of the "event_time" field.
func (m *RoomMessageMutation) ClearEventTime() {
	m.event_time = nil
	m.clearedFields[roommessage.FieldEventTime] = struct{}{}
}

// EventTimeCleared returns if the "event_time" field was cleared in this mutation.
func (m *RoomMessageMutation) EventTimeCleared() bool {
	_, ok := m.clearedFields[roommessage.FieldEventTime]
	return ok
}

// ResetEventTime resets all changes to the "event_time" field.
func (m *RoomMessageMutation) ResetEventTime() {
	m.event_time = nil
	delete(m.clearedFields, roommessage.FieldEventTime)
}

// SetText sets the "text" field.
func (m *RoomMessageMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *RoomMessageMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the RoomMessage entity.
// If the RoomMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMessageMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *RoomMessageMutation) ResetText() {
	m.text = nil
}

// Where appends a list predicates to the RoomMessageMutation builder.
func (m *RoomMessageMutation) Where(ps ...predicate.RoomMessage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoomMessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoomMessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RoomMessage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoomMessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoomMessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RoomMessage).
func (m *RoomMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoomMessageMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.uuid != nil {
		fields = append(fields, roommessage.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, roommessage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, roommessage.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, roommessage.FieldDeletedAt)
	}
	if m.sid != nil {
		fields = append(fields, roommessage.FieldSid)
	}
	if m.participant_sid != nil {
		fields = append(fields, roommessage.FieldParticipantSid)
	}
	if m.participant_name != nil {
		fields = append(fields, roommessage.FieldParticipantName)
	}
	if m._type != nil {
		fields = append(fields, roommessage.FieldType)
	}
	if m.is_reply != nil {
		fields = append(fields, roommessage.FieldIsReply)
	}
	if m.reply_id != nil {
		fields = append(fields, roommessage.FieldReplyID)
	}
	if m.event_time != nil {
		fields = append(fields, roommessage.FieldEventTime)
	}
	if m.text != nil {
		fields = append(fields, roommessage.FieldText)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoomMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case roommessage.FieldUUID:
		return m.UUID()
	case roommessage.FieldCreatedAt:
		return m.CreatedAt()
	case roommessage.FieldUpdatedAt:
		return m.UpdatedAt()
	case roommessage.FieldDeletedAt:
		return m.DeletedAt()
	case roommessage.FieldSid:
		return m.Sid()
	case roommessage.FieldParticipantSid:
		return m.ParticipantSid()
	case roommessage.FieldParticipantName:
		return m.ParticipantName()
	case roommessage.FieldType:
		return m.GetType()
	case roommessage.FieldIsReply:
		return m.IsReply()
	case roommessage.FieldReplyID:
		return m.ReplyID()
	case roommessage.FieldEventTime:
		return m.EventTime()
	case roommessage.FieldText:
		return m.Text()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoomMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case roommessage.FieldUUID:
		return m.OldUUID(ctx)
	case roommessage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case roommessage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case roommessage.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case roommessage.FieldSid:
		return m.OldSid(ctx)
	case roommessage.FieldParticipantSid:
		return m.OldParticipantSid(ctx)
	case roommessage.FieldParticipantName:
		return m.OldParticipantName(ctx)
	case roommessage.FieldType:
		return m.OldType(ctx)
	case roommessage.FieldIsReply:
		return m.OldIsReply(ctx)
	case roommessage.FieldReplyID:
		return m.OldReplyID(ctx)
	case roommessage.FieldEventTime:
		return m.OldEventTime(ctx)
	case roommessage.FieldText:
		return m.OldText(ctx)
	}
	return nil, fmt.Errorf("unknown RoomMessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case roommessage.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case roommessage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case roommessage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case roommessage.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case roommessage.FieldSid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSid(v)
		return nil
	case roommessage.FieldParticipantSid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParticipantSid(v)
		return nil
	case roommessage.FieldParticipantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParticipantName(v)
		return nil
	case roommessage.FieldType:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case roommessage.FieldIsReply:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsReply(v)
		return nil
	case roommessage.FieldReplyID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyID(v)
		return nil
	case roommessage.FieldEventTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventTime(v)
		return nil
	case roommessage.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	}
	return fmt.Errorf("unknown RoomMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoomMessageMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, roommessage.FieldType)
	}
	if m.addis_reply != nil {
		fields = append(fields, roommessage.FieldIsReply)
	}
	if m.addreply_id != nil {
		fields = append(fields, roommessage.FieldReplyID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoomMessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case roommessage.FieldType:
		return m.AddedType()
	case roommessage.FieldIsReply:
		return m.AddedIsReply()
	case roommessage.FieldReplyID:
		return m.AddedReplyID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case roommessage.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case roommessage.FieldIsReply:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsReply(v)
		return nil
	case roommessage.FieldReplyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReplyID(v)
		return nil
	}
	return fmt.Errorf("unknown RoomMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoomMessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(roommessage.FieldDeletedAt) {
		fields = append(fields, roommessage.FieldDeletedAt)
	}
	if m.FieldCleared(roommessage.FieldType) {
		fields = append(fields, roommessage.FieldType)
	}
	if m.FieldCleared(roommessage.FieldReplyID) {
		fields = append(fields, roommessage.FieldReplyID)
	}
	if m.FieldCleared(roommessage.FieldEventTime) {
		fields = append(fields, roommessage.FieldEventTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoomMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomMessageMutation) ClearField(name string) error {
	switch name {
	case roommessage.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case roommessage.FieldType:
		m.ClearType()
		return nil
	case roommessage.FieldReplyID:
		m.ClearReplyID()
		return nil
	case roommessage.FieldEventTime:
		m.ClearEventTime()
		return nil
	}
	return fmt.Errorf("unknown RoomMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoomMessageMutation) ResetField(name string) error {
	switch name {
	case roommessage.FieldUUID:
		m.ResetUUID()
		return nil
	case roommessage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case roommessage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case roommessage.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case roommessage.FieldSid:
		m.ResetSid()
		return nil
	case roommessage.FieldParticipantSid:
		m.ResetParticipantSid()
		return nil
	case roommessage.FieldParticipantName:
		m.ResetParticipantName()
		return nil
	case roommessage.FieldType:
		m.ResetType()
		return nil
	case roommessage.FieldIsReply:
		m.ResetIsReply()
		return nil
	case roommessage.FieldReplyID:
		m.ResetReplyID()
		return nil
	case roommessage.FieldEventTime:
		m.ResetEventTime()
		return nil
	case roommessage.FieldText:
		m.ResetText()
		return nil
	}
	return fmt.Errorf("unknown RoomMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoomMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoomMessageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoomMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoomMessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoomMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoomMessageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoomMessageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RoomMessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoomMessageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RoomMessage edge %s", name)
}

// RoomVodMutation represents an operation that mutates the RoomVod nodes in the graph.
type RoomVodMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	uuid          *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	sid           *string
	egress_id     *string
	status        *uint8
	addstatus     *int8
	platform      *uint8
	addplatform   *int8
	vod_type      *uint8
	addvod_type   *int8
	vod_path      *string
	vod_url       *string
	start_time    *time.Time
	complete_time *time.Time
	duration      *uint64
	addduration   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*RoomVod, error)
	predicates    []predicate.RoomVod
}

var _ ent.Mutation = (*RoomVodMutation)(nil)

// roomvodOption allows management of the mutation configuration using functional options.
type roomvodOption func(*RoomVodMutation)

// newRoomVodMutation creates new mutation for the RoomVod entity.
func newRoomVodMutation(c config, op Op, opts ...roomvodOption) *RoomVodMutation {
	m := &RoomVodMutation{
		config:        c,
		op:            op,
		typ:           TypeRoomVod,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomVodID sets the ID field of the mutation.
func withRoomVodID(id uint64) roomvodOption {
	return func(m *RoomVodMutation) {
		var (
			err   error
			once  sync.Once
			value *RoomVod
		)
		m.oldValue = func(ctx context.Context) (*RoomVod, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoomVod.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoomVod sets the old RoomVod of the mutation.
func withRoomVod(node *RoomVod) roomvodOption {
	return func(m *RoomVodMutation) {
		m.oldValue = func(context.Context) (*RoomVod, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomVodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomVodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RoomVod entities.
func (m *RoomVodMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoomVodMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoomVodMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RoomVod.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *RoomVodMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *RoomVodMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the RoomVod entity.
// If the RoomVod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomVodMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *RoomVodMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RoomVodMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoomVodMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RoomVod entity.
// If the RoomVod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomVodMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoomVodMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoomVodMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoomVodMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RoomVod entity.
// If the RoomVod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomVodMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoomVodMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoomVodMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoomVodMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RoomVod entity.
// If the RoomVod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomVodMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RoomVodMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[roomvod.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RoomVodMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[roomvod.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoomVodMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, roomvod.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *RoomVodMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoomVodMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RoomVod entity.
// If the RoomVod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomVodMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoomVodMutation) ResetName() {
	m.name = nil
}

// SetSid sets the "sid" field.
func (m *RoomVodMutation) SetSid(s string) {
	m.sid = &s
}

// Sid returns the value of the "sid" field in the mutation.
func (m *RoomVodMutation) Sid() (r string, exists bool) {
	v := m.sid
	if v == nil {
		return
	}
	return *v, true
}

// OldSid returns the old "sid" field's value of the RoomVod entity.
// If the RoomVod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomVodMutation) OldSid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSid: %w", err)
	}
	return oldValue.Sid, nil
}

// ResetSid resets all changes to the "sid" field.
func (m *RoomVodMutation) ResetSid() {
	m.sid = nil
}

// SetEgressID sets the "egress_id" field.
func (m *RoomVodMutation) SetEgressID(s string) {
	m.egress_id = &s
}

// EgressID returns the value of the "egress_id" field in the mutation.
func (m *RoomVodMutation) EgressID() (r string, exists bool) {
	v := m.egress_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEgressID returns the old "egress_id" field's value of the RoomVod entity.
// If the RoomVod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomVodMutation) OldEgressID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEgressID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEgressID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEgressID: %w", err)
	}
	return oldValue.EgressID, nil
}

// ResetEgressID resets all changes to the "egress_id" field.
func (m *RoomVodMutation) ResetEgressID() {
	m.egress_id = nil
}

// SetStatus sets the "status" field.
func (m *RoomVodMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RoomVodMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RoomVod entity.
// If the RoomVod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomVodMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *RoomVodMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RoomVodMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *RoomVodMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[roomvod.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *RoomVodMutation) StatusCleared() bool {
	_, ok := m.clearedFields[roomvod.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *RoomVodMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, roomvod.FieldStatus)
}

// SetPlatform sets the "platform" field.
func (m *RoomVodMutation) SetPlatform(u uint8) {
	m.platform = &u
	m.addplatform = nil
}

// Platform returns the value of the "platform" field in the mutation.
func (m *RoomVodMutation) Platform() (r uint8, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the RoomVod entity.
// If the RoomVod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomVodMutation) OldPlatform(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// AddPlatform adds u to the "platform" field.
func (m *RoomVodMutation) AddPlatform(u int8) {
	if m.addplatform != nil {
		*m.addplatform += u
	} else {
		m.addplatform = &u
	}
}

// AddedPlatform returns the value that was added to the "platform" field in this mutation.
func (m *RoomVodMutation) AddedPlatform() (r int8, exists bool) {
	v := m.addplatform
	if v == nil {
		return
	}
	return *v, true
}

// ClearPlatform clears the value of the "platform" field.
func (m *RoomVodMutation) ClearPlatform() {
	m.platform = nil
	m.addplatform = nil
	m.clearedFields[roomvod.FieldPlatform] = struct{}{}
}

// PlatformCleared returns if the "platform" field was cleared in this mutation.
func (m *RoomVodMutation) PlatformCleared() bool {
	_, ok := m.clearedFields[roomvod.FieldPlatform]
	return ok
}

// ResetPlatform resets all changes to the "platform" field.
func (m *RoomVodMutation) ResetPlatform() {
	m.platform = nil
	m.addplatform = nil
	delete(m.clearedFields, roomvod.FieldPlatform)
}

// SetVodType sets the "vod_type" field.
func (m *RoomVodMutation) SetVodType(u uint8) {
	m.vod_type = &u
	m.addvod_type = nil
}

// VodType returns the value of the "vod_type" field in the mutation.
func (m *RoomVodMutation) VodType() (r uint8, exists bool) {
	v := m.vod_type
	if v == nil {
		return
	}
	return *v, true
}

// OldVodType returns the old "vod_type" field's value of the RoomVod entity.
// If the RoomVod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomVodMutation) OldVodType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVodType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVodType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVodType: %w", err)
	}
	return oldValue.VodType, nil
}

// AddVodType adds u to the "vod_type" field.
func (m *RoomVodMutation) AddVodType(u int8) {
	if m.addvod_type != nil {
		*m.addvod_type += u
	} else {
		m.addvod_type = &u
	}
}

// AddedVodType returns the value that was added to the "vod_type" field in this mutation.
func (m *RoomVodMutation) AddedVodType() (r int8, exists bool) {
	v := m.addvod_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearVodType clears the value of the "vod_type" field.
func (m *RoomVodMutation) ClearVodType() {
	m.vod_type = nil
	m.addvod_type = nil
	m.clearedFields[roomvod.FieldVodType] = struct{}{}
}

// VodTypeCleared returns if the "vod_type" field was cleared in this mutation.
func (m *RoomVodMutation) VodTypeCleared() bool {
	_, ok := m.clearedFields[roomvod.FieldVodType]
	return ok
}

// ResetVodType resets all changes to the "vod_type" field.
func (m *RoomVodMutation) ResetVodType() {
	m.vod_type = nil
	m.addvod_type = nil
	delete(m.clearedFields, roomvod.FieldVodType)
}

// SetVodPath sets the "vod_path" field.
func (m *RoomVodMutation) SetVodPath(s string) {
	m.vod_path = &s
}

// VodPath returns the value of the "vod_path" field in the mutation.
func (m *RoomVodMutation) VodPath() (r string, exists bool) {
	v := m.vod_path
	if v == nil {
		return
	}
	return *v, true
}

// OldVodPath returns the old "vod_path" field's value of the RoomVod entity.
// If the RoomVod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomVodMutation) OldVodPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVodPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVodPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVodPath: %w", err)
	}
	return oldValue.VodPath, nil
}

// ClearVodPath clears the value of the "vod_path" field.
func (m *RoomVodMutation) ClearVodPath() {
	m.vod_path = nil
	m.clearedFields[roomvod.FieldVodPath] = struct{}{}
}

// VodPathCleared returns if the "vod_path" field was cleared in this mutation.
func (m *RoomVodMutation) VodPathCleared() bool {
	_, ok := m.clearedFields[roomvod.FieldVodPath]
	return ok
}

// ResetVodPath resets all changes to the "vod_path" field.
func (m *RoomVodMutation) ResetVodPath() {
	m.vod_path = nil
	delete(m.clearedFields, roomvod.FieldVodPath)
}

// SetVodURL sets the "vod_url" field.
func (m *RoomVodMutation) SetVodURL(s string) {
	m.vod_url = &s
}

// VodURL returns the value of the "vod_url" field in the mutation.
func (m *RoomVodMutation) VodURL() (r string, exists bool) {
	v := m.vod_url
	if v == nil {
		return
	}
	return *v, true
}

// OldVodURL returns the old "vod_url" field's value of the RoomVod entity.
// If the RoomVod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomVodMutation) OldVodURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVodURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVodURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVodURL: %w", err)
	}
	return oldValue.VodURL, nil
}

// ClearVodURL clears the value of the "vod_url" field.
func (m *RoomVodMutation) ClearVodURL() {
	m.vod_url = nil
	m.clearedFields[roomvod.FieldVodURL] = struct{}{}
}

// VodURLCleared returns if the "vod_url" field was cleared in this mutation.
func (m *RoomVodMutation) VodURLCleared() bool {
	_, ok := m.clearedFields[roomvod.FieldVodURL]
	return ok
}

// ResetVodURL resets all changes to the "vod_url" field.
func (m *RoomVodMutation) ResetVodURL() {
	m.vod_url = nil
	delete(m.clearedFields, roomvod.FieldVodURL)
}

// SetStartTime sets the "start_time" field.
func (m *RoomVodMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *RoomVodMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the RoomVod entity.
// If the RoomVod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomVodMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *RoomVodMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[roomvod.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *RoomVodMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[roomvod.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *RoomVodMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, roomvod.FieldStartTime)
}

// SetCompleteTime sets the "complete_time" field.
func (m *RoomVodMutation) SetCompleteTime(t time.Time) {
	m.complete_time = &t
}

// CompleteTime returns the value of the "complete_time" field in the mutation.
func (m *RoomVodMutation) CompleteTime() (r time.Time, exists bool) {
	v := m.complete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCompleteTime returns the old "complete_time" field's value of the RoomVod entity.
// If the RoomVod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomVodMutation) OldCompleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompleteTime: %w", err)
	}
	return oldValue.CompleteTime, nil
}

// ClearCompleteTime clears the value of the "complete_time" field.
func (m *RoomVodMutation) ClearCompleteTime() {
	m.complete_time = nil
	m.clearedFields[roomvod.FieldCompleteTime] = struct{}{}
}

// CompleteTimeCleared returns if the "complete_time" field was cleared in this mutation.
func (m *RoomVodMutation) CompleteTimeCleared() bool {
	_, ok := m.clearedFields[roomvod.FieldCompleteTime]
	return ok
}

// ResetCompleteTime resets all changes to the "complete_time" field.
func (m *RoomVodMutation) ResetCompleteTime() {
	m.complete_time = nil
	delete(m.clearedFields, roomvod.FieldCompleteTime)
}

// SetDuration sets the "duration" field.
func (m *RoomVodMutation) SetDuration(u uint64) {
	m.duration = &u
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *RoomVodMutation) Duration() (r uint64, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the RoomVod entity.
// If the RoomVod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomVodMutation) OldDuration(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds u to the "duration" field.
func (m *RoomVodMutation) AddDuration(u int64) {
	if m.addduration != nil {
		*m.addduration += u
	} else {
		m.addduration = &u
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *RoomVodMutation) AddedDuration() (r int64, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *RoomVodMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[roomvod.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *RoomVodMutation) DurationCleared() bool {
	_, ok := m.clearedFields[roomvod.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *RoomVodMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, roomvod.FieldDuration)
}

// Where appends a list predicates to the RoomVodMutation builder.
func (m *RoomVodMutation) Where(ps ...predicate.RoomVod) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoomVodMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoomVodMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RoomVod, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoomVodMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoomVodMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RoomVod).
func (m *RoomVodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoomVodMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.uuid != nil {
		fields = append(fields, roomvod.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, roomvod.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, roomvod.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, roomvod.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, roomvod.FieldName)
	}
	if m.sid != nil {
		fields = append(fields, roomvod.FieldSid)
	}
	if m.egress_id != nil {
		fields = append(fields, roomvod.FieldEgressID)
	}
	if m.status != nil {
		fields = append(fields, roomvod.FieldStatus)
	}
	if m.platform != nil {
		fields = append(fields, roomvod.FieldPlatform)
	}
	if m.vod_type != nil {
		fields = append(fields, roomvod.FieldVodType)
	}
	if m.vod_path != nil {
		fields = append(fields, roomvod.FieldVodPath)
	}
	if m.vod_url != nil {
		fields = append(fields, roomvod.FieldVodURL)
	}
	if m.start_time != nil {
		fields = append(fields, roomvod.FieldStartTime)
	}
	if m.complete_time != nil {
		fields = append(fields, roomvod.FieldCompleteTime)
	}
	if m.duration != nil {
		fields = append(fields, roomvod.FieldDuration)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoomVodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case roomvod.FieldUUID:
		return m.UUID()
	case roomvod.FieldCreatedAt:
		return m.CreatedAt()
	case roomvod.FieldUpdatedAt:
		return m.UpdatedAt()
	case roomvod.FieldDeletedAt:
		return m.DeletedAt()
	case roomvod.FieldName:
		return m.Name()
	case roomvod.FieldSid:
		return m.Sid()
	case roomvod.FieldEgressID:
		return m.EgressID()
	case roomvod.FieldStatus:
		return m.Status()
	case roomvod.FieldPlatform:
		return m.Platform()
	case roomvod.FieldVodType:
		return m.VodType()
	case roomvod.FieldVodPath:
		return m.VodPath()
	case roomvod.FieldVodURL:
		return m.VodURL()
	case roomvod.FieldStartTime:
		return m.StartTime()
	case roomvod.FieldCompleteTime:
		return m.CompleteTime()
	case roomvod.FieldDuration:
		return m.Duration()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoomVodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case roomvod.FieldUUID:
		return m.OldUUID(ctx)
	case roomvod.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case roomvod.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case roomvod.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case roomvod.FieldName:
		return m.OldName(ctx)
	case roomvod.FieldSid:
		return m.OldSid(ctx)
	case roomvod.FieldEgressID:
		return m.OldEgressID(ctx)
	case roomvod.FieldStatus:
		return m.OldStatus(ctx)
	case roomvod.FieldPlatform:
		return m.OldPlatform(ctx)
	case roomvod.FieldVodType:
		return m.OldVodType(ctx)
	case roomvod.FieldVodPath:
		return m.OldVodPath(ctx)
	case roomvod.FieldVodURL:
		return m.OldVodURL(ctx)
	case roomvod.FieldStartTime:
		return m.OldStartTime(ctx)
	case roomvod.FieldCompleteTime:
		return m.OldCompleteTime(ctx)
	case roomvod.FieldDuration:
		return m.OldDuration(ctx)
	}
	return nil, fmt.Errorf("unknown RoomVod field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomVodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case roomvod.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case roomvod.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case roomvod.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case roomvod.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case roomvod.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case roomvod.FieldSid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSid(v)
		return nil
	case roomvod.FieldEgressID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEgressID(v)
		return nil
	case roomvod.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case roomvod.FieldPlatform:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case roomvod.FieldVodType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVodType(v)
		return nil
	case roomvod.FieldVodPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVodPath(v)
		return nil
	case roomvod.FieldVodURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVodURL(v)
		return nil
	case roomvod.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case roomvod.FieldCompleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompleteTime(v)
		return nil
	case roomvod.FieldDuration:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	}
	return fmt.Errorf("unknown RoomVod field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoomVodMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, roomvod.FieldStatus)
	}
	if m.addplatform != nil {
		fields = append(fields, roomvod.FieldPlatform)
	}
	if m.addvod_type != nil {
		fields = append(fields, roomvod.FieldVodType)
	}
	if m.addduration != nil {
		fields = append(fields, roomvod.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoomVodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case roomvod.FieldStatus:
		return m.AddedStatus()
	case roomvod.FieldPlatform:
		return m.AddedPlatform()
	case roomvod.FieldVodType:
		return m.AddedVodType()
	case roomvod.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomVodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case roomvod.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case roomvod.FieldPlatform:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlatform(v)
		return nil
	case roomvod.FieldVodType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVodType(v)
		return nil
	case roomvod.FieldDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown RoomVod numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoomVodMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(roomvod.FieldDeletedAt) {
		fields = append(fields, roomvod.FieldDeletedAt)
	}
	if m.FieldCleared(roomvod.FieldStatus) {
		fields = append(fields, roomvod.FieldStatus)
	}
	if m.FieldCleared(roomvod.FieldPlatform) {
		fields = append(fields, roomvod.FieldPlatform)
	}
	if m.FieldCleared(roomvod.FieldVodType) {
		fields = append(fields, roomvod.FieldVodType)
	}
	if m.FieldCleared(roomvod.FieldVodPath) {
		fields = append(fields, roomvod.FieldVodPath)
	}
	if m.FieldCleared(roomvod.FieldVodURL) {
		fields = append(fields, roomvod.FieldVodURL)
	}
	if m.FieldCleared(roomvod.FieldStartTime) {
		fields = append(fields, roomvod.FieldStartTime)
	}
	if m.FieldCleared(roomvod.FieldCompleteTime) {
		fields = append(fields, roomvod.FieldCompleteTime)
	}
	if m.FieldCleared(roomvod.FieldDuration) {
		fields = append(fields, roomvod.FieldDuration)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoomVodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomVodMutation) ClearField(name string) error {
	switch name {
	case roomvod.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case roomvod.FieldStatus:
		m.ClearStatus()
		return nil
	case roomvod.FieldPlatform:
		m.ClearPlatform()
		return nil
	case roomvod.FieldVodType:
		m.ClearVodType()
		return nil
	case roomvod.FieldVodPath:
		m.ClearVodPath()
		return nil
	case roomvod.FieldVodURL:
		m.ClearVodURL()
		return nil
	case roomvod.FieldStartTime:
		m.ClearStartTime()
		return nil
	case roomvod.FieldCompleteTime:
		m.ClearCompleteTime()
		return nil
	case roomvod.FieldDuration:
		m.ClearDuration()
		return nil
	}
	return fmt.Errorf("unknown RoomVod nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoomVodMutation) ResetField(name string) error {
	switch name {
	case roomvod.FieldUUID:
		m.ResetUUID()
		return nil
	case roomvod.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case roomvod.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case roomvod.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case roomvod.FieldName:
		m.ResetName()
		return nil
	case roomvod.FieldSid:
		m.ResetSid()
		return nil
	case roomvod.FieldEgressID:
		m.ResetEgressID()
		return nil
	case roomvod.FieldStatus:
		m.ResetStatus()
		return nil
	case roomvod.FieldPlatform:
		m.ResetPlatform()
		return nil
	case roomvod.FieldVodType:
		m.ResetVodType()
		return nil
	case roomvod.FieldVodPath:
		m.ResetVodPath()
		return nil
	case roomvod.FieldVodURL:
		m.ResetVodURL()
		return nil
	case roomvod.FieldStartTime:
		m.ResetStartTime()
		return nil
	case roomvod.FieldCompleteTime:
		m.ResetCompleteTime()
		return nil
	case roomvod.FieldDuration:
		m.ResetDuration()
		return nil
	}
	return fmt.Errorf("unknown RoomVod field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoomVodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoomVodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoomVodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoomVodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoomVodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoomVodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoomVodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RoomVod unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoomVodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RoomVod edge %s", name)
}

// RoomWebhookMutation represents an operation that mutates the RoomWebhook nodes in the graph.
type RoomWebhookMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	uuid          *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	sid           *string
	event         *string
	event_time    *time.Time
	room          **livekit.Room
	participant   **livekit.ParticipantInfo
	track         **livekit.TrackInfo
	egressInfo    **livekit.EgressInfo
	ingressInfo   **livekit.IngressInfo
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*RoomWebhook, error)
	predicates    []predicate.RoomWebhook
}

var _ ent.Mutation = (*RoomWebhookMutation)(nil)

// roomwebhookOption allows management of the mutation configuration using functional options.
type roomwebhookOption func(*RoomWebhookMutation)

// newRoomWebhookMutation creates new mutation for the RoomWebhook entity.
func newRoomWebhookMutation(c config, op Op, opts ...roomwebhookOption) *RoomWebhookMutation {
	m := &RoomWebhookMutation{
		config:        c,
		op:            op,
		typ:           TypeRoomWebhook,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomWebhookID sets the ID field of the mutation.
func withRoomWebhookID(id uint64) roomwebhookOption {
	return func(m *RoomWebhookMutation) {
		var (
			err   error
			once  sync.Once
			value *RoomWebhook
		)
		m.oldValue = func(ctx context.Context) (*RoomWebhook, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoomWebhook.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoomWebhook sets the old RoomWebhook of the mutation.
func withRoomWebhook(node *RoomWebhook) roomwebhookOption {
	return func(m *RoomWebhookMutation) {
		m.oldValue = func(context.Context) (*RoomWebhook, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomWebhookMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomWebhookMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RoomWebhook entities.
func (m *RoomWebhookMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoomWebhookMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoomWebhookMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RoomWebhook.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *RoomWebhookMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *RoomWebhookMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the RoomWebhook entity.
// If the RoomWebhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomWebhookMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *RoomWebhookMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RoomWebhookMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoomWebhookMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RoomWebhook entity.
// If the RoomWebhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomWebhookMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoomWebhookMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoomWebhookMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoomWebhookMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RoomWebhook entity.
// If the RoomWebhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomWebhookMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoomWebhookMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoomWebhookMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoomWebhookMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RoomWebhook entity.
// If the RoomWebhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomWebhookMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RoomWebhookMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[roomwebhook.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RoomWebhookMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[roomwebhook.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoomWebhookMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, roomwebhook.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *RoomWebhookMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoomWebhookMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RoomWebhook entity.
// If the RoomWebhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomWebhookMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoomWebhookMutation) ResetName() {
	m.name = nil
}

// SetSid sets the "sid" field.
func (m *RoomWebhookMutation) SetSid(s string) {
	m.sid = &s
}

// Sid returns the value of the "sid" field in the mutation.
func (m *RoomWebhookMutation) Sid() (r string, exists bool) {
	v := m.sid
	if v == nil {
		return
	}
	return *v, true
}

// OldSid returns the old "sid" field's value of the RoomWebhook entity.
// If the RoomWebhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomWebhookMutation) OldSid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSid: %w", err)
	}
	return oldValue.Sid, nil
}

// ResetSid resets all changes to the "sid" field.
func (m *RoomWebhookMutation) ResetSid() {
	m.sid = nil
}

// SetEvent sets the "event" field.
func (m *RoomWebhookMutation) SetEvent(s string) {
	m.event = &s
}

// Event returns the value of the "event" field in the mutation.
func (m *RoomWebhookMutation) Event() (r string, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEvent returns the old "event" field's value of the RoomWebhook entity.
// If the RoomWebhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomWebhookMutation) OldEvent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvent: %w", err)
	}
	return oldValue.Event, nil
}

// ResetEvent resets all changes to the "event" field.
func (m *RoomWebhookMutation) ResetEvent() {
	m.event = nil
}

// SetEventTime sets the "event_time" field.
func (m *RoomWebhookMutation) SetEventTime(t time.Time) {
	m.event_time = &t
}

// EventTime returns the value of the "event_time" field in the mutation.
func (m *RoomWebhookMutation) EventTime() (r time.Time, exists bool) {
	v := m.event_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEventTime returns the old "event_time" field's value of the RoomWebhook entity.
// If the RoomWebhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomWebhookMutation) OldEventTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventTime: %w", err)
	}
	return oldValue.EventTime, nil
}

// ClearEventTime clears the value of the "event_time" field.
func (m *RoomWebhookMutation) ClearEventTime() {
	m.event_time = nil
	m.clearedFields[roomwebhook.FieldEventTime] = struct{}{}
}

// EventTimeCleared returns if the "event_time" field was cleared in this mutation.
func (m *RoomWebhookMutation) EventTimeCleared() bool {
	_, ok := m.clearedFields[roomwebhook.FieldEventTime]
	return ok
}

// ResetEventTime resets all changes to the "event_time" field.
func (m *RoomWebhookMutation) ResetEventTime() {
	m.event_time = nil
	delete(m.clearedFields, roomwebhook.FieldEventTime)
}

// SetRoom sets the "room" field.
func (m *RoomWebhookMutation) SetRoom(l *livekit.Room) {
	m.room = &l
}

// Room returns the value of the "room" field in the mutation.
func (m *RoomWebhookMutation) Room() (r *livekit.Room, exists bool) {
	v := m.room
	if v == nil {
		return
	}
	return *v, true
}

// OldRoom returns the old "room" field's value of the RoomWebhook entity.
// If the RoomWebhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomWebhookMutation) OldRoom(ctx context.Context) (v *livekit.Room, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoom: %w", err)
	}
	return oldValue.Room, nil
}

// ClearRoom clears the value of the "room" field.
func (m *RoomWebhookMutation) ClearRoom() {
	m.room = nil
	m.clearedFields[roomwebhook.FieldRoom] = struct{}{}
}

// RoomCleared returns if the "room" field was cleared in this mutation.
func (m *RoomWebhookMutation) RoomCleared() bool {
	_, ok := m.clearedFields[roomwebhook.FieldRoom]
	return ok
}

// ResetRoom resets all changes to the "room" field.
func (m *RoomWebhookMutation) ResetRoom() {
	m.room = nil
	delete(m.clearedFields, roomwebhook.FieldRoom)
}

// SetParticipant sets the "participant" field.
func (m *RoomWebhookMutation) SetParticipant(li *livekit.ParticipantInfo) {
	m.participant = &li
}

// Participant returns the value of the "participant" field in the mutation.
func (m *RoomWebhookMutation) Participant() (r *livekit.ParticipantInfo, exists bool) {
	v := m.participant
	if v == nil {
		return
	}
	return *v, true
}

// OldParticipant returns the old "participant" field's value of the RoomWebhook entity.
// If the RoomWebhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomWebhookMutation) OldParticipant(ctx context.Context) (v *livekit.ParticipantInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParticipant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParticipant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParticipant: %w", err)
	}
	return oldValue.Participant, nil
}

// ClearParticipant clears the value of the "participant" field.
func (m *RoomWebhookMutation) ClearParticipant() {
	m.participant = nil
	m.clearedFields[roomwebhook.FieldParticipant] = struct{}{}
}

// ParticipantCleared returns if the "participant" field was cleared in this mutation.
func (m *RoomWebhookMutation) ParticipantCleared() bool {
	_, ok := m.clearedFields[roomwebhook.FieldParticipant]
	return ok
}

// ResetParticipant resets all changes to the "participant" field.
func (m *RoomWebhookMutation) ResetParticipant() {
	m.participant = nil
	delete(m.clearedFields, roomwebhook.FieldParticipant)
}

// SetTrack sets the "track" field.
func (m *RoomWebhookMutation) SetTrack(li *livekit.TrackInfo) {
	m.track = &li
}

// Track returns the value of the "track" field in the mutation.
func (m *RoomWebhookMutation) Track() (r *livekit.TrackInfo, exists bool) {
	v := m.track
	if v == nil {
		return
	}
	return *v, true
}

// OldTrack returns the old "track" field's value of the RoomWebhook entity.
// If the RoomWebhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomWebhookMutation) OldTrack(ctx context.Context) (v *livekit.TrackInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrack is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrack requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrack: %w", err)
	}
	return oldValue.Track, nil
}

// ClearTrack clears the value of the "track" field.
func (m *RoomWebhookMutation) ClearTrack() {
	m.track = nil
	m.clearedFields[roomwebhook.FieldTrack] = struct{}{}
}

// TrackCleared returns if the "track" field was cleared in this mutation.
func (m *RoomWebhookMutation) TrackCleared() bool {
	_, ok := m.clearedFields[roomwebhook.FieldTrack]
	return ok
}

// ResetTrack resets all changes to the "track" field.
func (m *RoomWebhookMutation) ResetTrack() {
	m.track = nil
	delete(m.clearedFields, roomwebhook.FieldTrack)
}

// SetEgressInfo sets the "egressInfo" field.
func (m *RoomWebhookMutation) SetEgressInfo(li *livekit.EgressInfo) {
	m.egressInfo = &li
}

// EgressInfo returns the value of the "egressInfo" field in the mutation.
func (m *RoomWebhookMutation) EgressInfo() (r *livekit.EgressInfo, exists bool) {
	v := m.egressInfo
	if v == nil {
		return
	}
	return *v, true
}

// OldEgressInfo returns the old "egressInfo" field's value of the RoomWebhook entity.
// If the RoomWebhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomWebhookMutation) OldEgressInfo(ctx context.Context) (v *livekit.EgressInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEgressInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEgressInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEgressInfo: %w", err)
	}
	return oldValue.EgressInfo, nil
}

// ClearEgressInfo clears the value of the "egressInfo" field.
func (m *RoomWebhookMutation) ClearEgressInfo() {
	m.egressInfo = nil
	m.clearedFields[roomwebhook.FieldEgressInfo] = struct{}{}
}

// EgressInfoCleared returns if the "egressInfo" field was cleared in this mutation.
func (m *RoomWebhookMutation) EgressInfoCleared() bool {
	_, ok := m.clearedFields[roomwebhook.FieldEgressInfo]
	return ok
}

// ResetEgressInfo resets all changes to the "egressInfo" field.
func (m *RoomWebhookMutation) ResetEgressInfo() {
	m.egressInfo = nil
	delete(m.clearedFields, roomwebhook.FieldEgressInfo)
}

// SetIngressInfo sets the "ingressInfo" field.
func (m *RoomWebhookMutation) SetIngressInfo(li *livekit.IngressInfo) {
	m.ingressInfo = &li
}

// IngressInfo returns the value of the "ingressInfo" field in the mutation.
func (m *RoomWebhookMutation) IngressInfo() (r *livekit.IngressInfo, exists bool) {
	v := m.ingressInfo
	if v == nil {
		return
	}
	return *v, true
}

// OldIngressInfo returns the old "ingressInfo" field's value of the RoomWebhook entity.
// If the RoomWebhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomWebhookMutation) OldIngressInfo(ctx context.Context) (v *livekit.IngressInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIngressInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIngressInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIngressInfo: %w", err)
	}
	return oldValue.IngressInfo, nil
}

// ClearIngressInfo clears the value of the "ingressInfo" field.
func (m *RoomWebhookMutation) ClearIngressInfo() {
	m.ingressInfo = nil
	m.clearedFields[roomwebhook.FieldIngressInfo] = struct{}{}
}

// IngressInfoCleared returns if the "ingressInfo" field was cleared in this mutation.
func (m *RoomWebhookMutation) IngressInfoCleared() bool {
	_, ok := m.clearedFields[roomwebhook.FieldIngressInfo]
	return ok
}

// ResetIngressInfo resets all changes to the "ingressInfo" field.
func (m *RoomWebhookMutation) ResetIngressInfo() {
	m.ingressInfo = nil
	delete(m.clearedFields, roomwebhook.FieldIngressInfo)
}

// Where appends a list predicates to the RoomWebhookMutation builder.
func (m *RoomWebhookMutation) Where(ps ...predicate.RoomWebhook) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoomWebhookMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoomWebhookMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RoomWebhook, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoomWebhookMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoomWebhookMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RoomWebhook).
func (m *RoomWebhookMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoomWebhookMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.uuid != nil {
		fields = append(fields, roomwebhook.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, roomwebhook.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, roomwebhook.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, roomwebhook.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, roomwebhook.FieldName)
	}
	if m.sid != nil {
		fields = append(fields, roomwebhook.FieldSid)
	}
	if m.event != nil {
		fields = append(fields, roomwebhook.FieldEvent)
	}
	if m.event_time != nil {
		fields = append(fields, roomwebhook.FieldEventTime)
	}
	if m.room != nil {
		fields = append(fields, roomwebhook.FieldRoom)
	}
	if m.participant != nil {
		fields = append(fields, roomwebhook.FieldParticipant)
	}
	if m.track != nil {
		fields = append(fields, roomwebhook.FieldTrack)
	}
	if m.egressInfo != nil {
		fields = append(fields, roomwebhook.FieldEgressInfo)
	}
	if m.ingressInfo != nil {
		fields = append(fields, roomwebhook.FieldIngressInfo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoomWebhookMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case roomwebhook.FieldUUID:
		return m.UUID()
	case roomwebhook.FieldCreatedAt:
		return m.CreatedAt()
	case roomwebhook.FieldUpdatedAt:
		return m.UpdatedAt()
	case roomwebhook.FieldDeletedAt:
		return m.DeletedAt()
	case roomwebhook.FieldName:
		return m.Name()
	case roomwebhook.FieldSid:
		return m.Sid()
	case roomwebhook.FieldEvent:
		return m.Event()
	case roomwebhook.FieldEventTime:
		return m.EventTime()
	case roomwebhook.FieldRoom:
		return m.Room()
	case roomwebhook.FieldParticipant:
		return m.Participant()
	case roomwebhook.FieldTrack:
		return m.Track()
	case roomwebhook.FieldEgressInfo:
		return m.EgressInfo()
	case roomwebhook.FieldIngressInfo:
		return m.IngressInfo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoomWebhookMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case roomwebhook.FieldUUID:
		return m.OldUUID(ctx)
	case roomwebhook.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case roomwebhook.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case roomwebhook.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case roomwebhook.FieldName:
		return m.OldName(ctx)
	case roomwebhook.FieldSid:
		return m.OldSid(ctx)
	case roomwebhook.FieldEvent:
		return m.OldEvent(ctx)
	case roomwebhook.FieldEventTime:
		return m.OldEventTime(ctx)
	case roomwebhook.FieldRoom:
		return m.OldRoom(ctx)
	case roomwebhook.FieldParticipant:
		return m.OldParticipant(ctx)
	case roomwebhook.FieldTrack:
		return m.OldTrack(ctx)
	case roomwebhook.FieldEgressInfo:
		return m.OldEgressInfo(ctx)
	case roomwebhook.FieldIngressInfo:
		return m.OldIngressInfo(ctx)
	}
	return nil, fmt.Errorf("unknown RoomWebhook field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomWebhookMutation) SetField(name string, value ent.Value) error {
	switch name {
	case roomwebhook.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case roomwebhook.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case roomwebhook.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case roomwebhook.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case roomwebhook.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case roomwebhook.FieldSid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSid(v)
		return nil
	case roomwebhook.FieldEvent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvent(v)
		return nil
	case roomwebhook.FieldEventTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventTime(v)
		return nil
	case roomwebhook.FieldRoom:
		v, ok := value.(*livekit.Room)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoom(v)
		return nil
	case roomwebhook.FieldParticipant:
		v, ok := value.(*livekit.ParticipantInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParticipant(v)
		return nil
	case roomwebhook.FieldTrack:
		v, ok := value.(*livekit.TrackInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrack(v)
		return nil
	case roomwebhook.FieldEgressInfo:
		v, ok := value.(*livekit.EgressInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEgressInfo(v)
		return nil
	case roomwebhook.FieldIngressInfo:
		v, ok := value.(*livekit.IngressInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIngressInfo(v)
		return nil
	}
	return fmt.Errorf("unknown RoomWebhook field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoomWebhookMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoomWebhookMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomWebhookMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RoomWebhook numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoomWebhookMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(roomwebhook.FieldDeletedAt) {
		fields = append(fields, roomwebhook.FieldDeletedAt)
	}
	if m.FieldCleared(roomwebhook.FieldEventTime) {
		fields = append(fields, roomwebhook.FieldEventTime)
	}
	if m.FieldCleared(roomwebhook.FieldRoom) {
		fields = append(fields, roomwebhook.FieldRoom)
	}
	if m.FieldCleared(roomwebhook.FieldParticipant) {
		fields = append(fields, roomwebhook.FieldParticipant)
	}
	if m.FieldCleared(roomwebhook.FieldTrack) {
		fields = append(fields, roomwebhook.FieldTrack)
	}
	if m.FieldCleared(roomwebhook.FieldEgressInfo) {
		fields = append(fields, roomwebhook.FieldEgressInfo)
	}
	if m.FieldCleared(roomwebhook.FieldIngressInfo) {
		fields = append(fields, roomwebhook.FieldIngressInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoomWebhookMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomWebhookMutation) ClearField(name string) error {
	switch name {
	case roomwebhook.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case roomwebhook.FieldEventTime:
		m.ClearEventTime()
		return nil
	case roomwebhook.FieldRoom:
		m.ClearRoom()
		return nil
	case roomwebhook.FieldParticipant:
		m.ClearParticipant()
		return nil
	case roomwebhook.FieldTrack:
		m.ClearTrack()
		return nil
	case roomwebhook.FieldEgressInfo:
		m.ClearEgressInfo()
		return nil
	case roomwebhook.FieldIngressInfo:
		m.ClearIngressInfo()
		return nil
	}
	return fmt.Errorf("unknown RoomWebhook nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoomWebhookMutation) ResetField(name string) error {
	switch name {
	case roomwebhook.FieldUUID:
		m.ResetUUID()
		return nil
	case roomwebhook.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case roomwebhook.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case roomwebhook.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case roomwebhook.FieldName:
		m.ResetName()
		return nil
	case roomwebhook.FieldSid:
		m.ResetSid()
		return nil
	case roomwebhook.FieldEvent:
		m.ResetEvent()
		return nil
	case roomwebhook.FieldEventTime:
		m.ResetEventTime()
		return nil
	case roomwebhook.FieldRoom:
		m.ResetRoom()
		return nil
	case roomwebhook.FieldParticipant:
		m.ResetParticipant()
		return nil
	case roomwebhook.FieldTrack:
		m.ResetTrack()
		return nil
	case roomwebhook.FieldEgressInfo:
		m.ResetEgressInfo()
		return nil
	case roomwebhook.FieldIngressInfo:
		m.ResetIngressInfo()
		return nil
	}
	return fmt.Errorf("unknown RoomWebhook field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoomWebhookMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoomWebhookMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoomWebhookMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoomWebhookMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoomWebhookMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoomWebhookMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoomWebhookMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RoomWebhook unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoomWebhookMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RoomWebhook edge %s", name)
}

// ServiceWebhookLogMutation represents an operation that mutates the ServiceWebhookLog nodes in the graph.
type ServiceWebhookLogMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uuid           *string
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	name           *string
	sid            *string
	url            *string
	status_code    *uint16
	addstatus_code *int16
	times          *uint8
	addtimes       *int8
	request        **schema.WebhookRequest
	resp           **schema.WebhookResp
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*ServiceWebhookLog, error)
	predicates     []predicate.ServiceWebhookLog
}

var _ ent.Mutation = (*ServiceWebhookLogMutation)(nil)

// servicewebhooklogOption allows management of the mutation configuration using functional options.
type servicewebhooklogOption func(*ServiceWebhookLogMutation)

// newServiceWebhookLogMutation creates new mutation for the ServiceWebhookLog entity.
func newServiceWebhookLogMutation(c config, op Op, opts ...servicewebhooklogOption) *ServiceWebhookLogMutation {
	m := &ServiceWebhookLogMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceWebhookLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceWebhookLogID sets the ID field of the mutation.
func withServiceWebhookLogID(id uint64) servicewebhooklogOption {
	return func(m *ServiceWebhookLogMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceWebhookLog
		)
		m.oldValue = func(ctx context.Context) (*ServiceWebhookLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceWebhookLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceWebhookLog sets the old ServiceWebhookLog of the mutation.
func withServiceWebhookLog(node *ServiceWebhookLog) servicewebhooklogOption {
	return func(m *ServiceWebhookLogMutation) {
		m.oldValue = func(context.Context) (*ServiceWebhookLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceWebhookLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceWebhookLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceWebhookLog entities.
func (m *ServiceWebhookLogMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceWebhookLogMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceWebhookLogMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceWebhookLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *ServiceWebhookLogMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *ServiceWebhookLogMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the ServiceWebhookLog entity.
// If the ServiceWebhookLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceWebhookLogMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *ServiceWebhookLogMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ServiceWebhookLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServiceWebhookLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServiceWebhookLog entity.
// If the ServiceWebhookLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceWebhookLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServiceWebhookLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServiceWebhookLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServiceWebhookLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServiceWebhookLog entity.
// If the ServiceWebhookLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceWebhookLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServiceWebhookLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ServiceWebhookLogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ServiceWebhookLogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ServiceWebhookLog entity.
// If the ServiceWebhookLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceWebhookLogMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ServiceWebhookLogMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[servicewebhooklog.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ServiceWebhookLogMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[servicewebhooklog.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ServiceWebhookLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, servicewebhooklog.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ServiceWebhookLogMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServiceWebhookLogMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ServiceWebhookLog entity.
// If the ServiceWebhookLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceWebhookLogMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServiceWebhookLogMutation) ResetName() {
	m.name = nil
}

// SetSid sets the "sid" field.
func (m *ServiceWebhookLogMutation) SetSid(s string) {
	m.sid = &s
}

// Sid returns the value of the "sid" field in the mutation.
func (m *ServiceWebhookLogMutation) Sid() (r string, exists bool) {
	v := m.sid
	if v == nil {
		return
	}
	return *v, true
}

// OldSid returns the old "sid" field's value of the ServiceWebhookLog entity.
// If the ServiceWebhookLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceWebhookLogMutation) OldSid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSid: %w", err)
	}
	return oldValue.Sid, nil
}

// ResetSid resets all changes to the "sid" field.
func (m *ServiceWebhookLogMutation) ResetSid() {
	m.sid = nil
}

// SetURL sets the "url" field.
func (m *ServiceWebhookLogMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ServiceWebhookLogMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the ServiceWebhookLog entity.
// If the ServiceWebhookLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceWebhookLogMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *ServiceWebhookLogMutation) ResetURL() {
	m.url = nil
}

// SetStatusCode sets the "status_code" field.
func (m *ServiceWebhookLogMutation) SetStatusCode(u uint16) {
	m.status_code = &u
	m.addstatus_code = nil
}

// StatusCode returns the value of the "status_code" field in the mutation.
func (m *ServiceWebhookLogMutation) StatusCode() (r uint16, exists bool) {
	v := m.status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusCode returns the old "status_code" field's value of the ServiceWebhookLog entity.
// If the ServiceWebhookLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceWebhookLogMutation) OldStatusCode(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusCode: %w", err)
	}
	return oldValue.StatusCode, nil
}

// AddStatusCode adds u to the "status_code" field.
func (m *ServiceWebhookLogMutation) AddStatusCode(u int16) {
	if m.addstatus_code != nil {
		*m.addstatus_code += u
	} else {
		m.addstatus_code = &u
	}
}

// AddedStatusCode returns the value that was added to the "status_code" field in this mutation.
func (m *ServiceWebhookLogMutation) AddedStatusCode() (r int16, exists bool) {
	v := m.addstatus_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatusCode clears the value of the "status_code" field.
func (m *ServiceWebhookLogMutation) ClearStatusCode() {
	m.status_code = nil
	m.addstatus_code = nil
	m.clearedFields[servicewebhooklog.FieldStatusCode] = struct{}{}
}

// StatusCodeCleared returns if the "status_code" field was cleared in this mutation.
func (m *ServiceWebhookLogMutation) StatusCodeCleared() bool {
	_, ok := m.clearedFields[servicewebhooklog.FieldStatusCode]
	return ok
}

// ResetStatusCode resets all changes to the "status_code" field.
func (m *ServiceWebhookLogMutation) ResetStatusCode() {
	m.status_code = nil
	m.addstatus_code = nil
	delete(m.clearedFields, servicewebhooklog.FieldStatusCode)
}

// SetTimes sets the "times" field.
func (m *ServiceWebhookLogMutation) SetTimes(u uint8) {
	m.times = &u
	m.addtimes = nil
}

// Times returns the value of the "times" field in the mutation.
func (m *ServiceWebhookLogMutation) Times() (r uint8, exists bool) {
	v := m.times
	if v == nil {
		return
	}
	return *v, true
}

// OldTimes returns the old "times" field's value of the ServiceWebhookLog entity.
// If the ServiceWebhookLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceWebhookLogMutation) OldTimes(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimes: %w", err)
	}
	return oldValue.Times, nil
}

// AddTimes adds u to the "times" field.
func (m *ServiceWebhookLogMutation) AddTimes(u int8) {
	if m.addtimes != nil {
		*m.addtimes += u
	} else {
		m.addtimes = &u
	}
}

// AddedTimes returns the value that was added to the "times" field in this mutation.
func (m *ServiceWebhookLogMutation) AddedTimes() (r int8, exists bool) {
	v := m.addtimes
	if v == nil {
		return
	}
	return *v, true
}

// ClearTimes clears the value of the "times" field.
func (m *ServiceWebhookLogMutation) ClearTimes() {
	m.times = nil
	m.addtimes = nil
	m.clearedFields[servicewebhooklog.FieldTimes] = struct{}{}
}

// TimesCleared returns if the "times" field was cleared in this mutation.
func (m *ServiceWebhookLogMutation) TimesCleared() bool {
	_, ok := m.clearedFields[servicewebhooklog.FieldTimes]
	return ok
}

// ResetTimes resets all changes to the "times" field.
func (m *ServiceWebhookLogMutation) ResetTimes() {
	m.times = nil
	m.addtimes = nil
	delete(m.clearedFields, servicewebhooklog.FieldTimes)
}

// SetRequest sets the "request" field.
func (m *ServiceWebhookLogMutation) SetRequest(sr *schema.WebhookRequest) {
	m.request = &sr
}

// Request returns the value of the "request" field in the mutation.
func (m *ServiceWebhookLogMutation) Request() (r *schema.WebhookRequest, exists bool) {
	v := m.request
	if v == nil {
		return
	}
	return *v, true
}

// OldRequest returns the old "request" field's value of the ServiceWebhookLog entity.
// If the ServiceWebhookLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceWebhookLogMutation) OldRequest(ctx context.Context) (v *schema.WebhookRequest, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequest: %w", err)
	}
	return oldValue.Request, nil
}

// ClearRequest clears the value of the "request" field.
func (m *ServiceWebhookLogMutation) ClearRequest() {
	m.request = nil
	m.clearedFields[servicewebhooklog.FieldRequest] = struct{}{}
}

// RequestCleared returns if the "request" field was cleared in this mutation.
func (m *ServiceWebhookLogMutation) RequestCleared() bool {
	_, ok := m.clearedFields[servicewebhooklog.FieldRequest]
	return ok
}

// ResetRequest resets all changes to the "request" field.
func (m *ServiceWebhookLogMutation) ResetRequest() {
	m.request = nil
	delete(m.clearedFields, servicewebhooklog.FieldRequest)
}

// SetResp sets the "resp" field.
func (m *ServiceWebhookLogMutation) SetResp(sr *schema.WebhookResp) {
	m.resp = &sr
}

// Resp returns the value of the "resp" field in the mutation.
func (m *ServiceWebhookLogMutation) Resp() (r *schema.WebhookResp, exists bool) {
	v := m.resp
	if v == nil {
		return
	}
	return *v, true
}

// OldResp returns the old "resp" field's value of the ServiceWebhookLog entity.
// If the ServiceWebhookLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceWebhookLogMutation) OldResp(ctx context.Context) (v *schema.WebhookResp, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResp: %w", err)
	}
	return oldValue.Resp, nil
}

// ClearResp clears the value of the "resp" field.
func (m *ServiceWebhookLogMutation) ClearResp() {
	m.resp = nil
	m.clearedFields[servicewebhooklog.FieldResp] = struct{}{}
}

// RespCleared returns if the "resp" field was cleared in this mutation.
func (m *ServiceWebhookLogMutation) RespCleared() bool {
	_, ok := m.clearedFields[servicewebhooklog.FieldResp]
	return ok
}

// ResetResp resets all changes to the "resp" field.
func (m *ServiceWebhookLogMutation) ResetResp() {
	m.resp = nil
	delete(m.clearedFields, servicewebhooklog.FieldResp)
}

// Where appends a list predicates to the ServiceWebhookLogMutation builder.
func (m *ServiceWebhookLogMutation) Where(ps ...predicate.ServiceWebhookLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceWebhookLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceWebhookLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceWebhookLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceWebhookLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceWebhookLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceWebhookLog).
func (m *ServiceWebhookLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceWebhookLogMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.uuid != nil {
		fields = append(fields, servicewebhooklog.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, servicewebhooklog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servicewebhooklog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, servicewebhooklog.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, servicewebhooklog.FieldName)
	}
	if m.sid != nil {
		fields = append(fields, servicewebhooklog.FieldSid)
	}
	if m.url != nil {
		fields = append(fields, servicewebhooklog.FieldURL)
	}
	if m.status_code != nil {
		fields = append(fields, servicewebhooklog.FieldStatusCode)
	}
	if m.times != nil {
		fields = append(fields, servicewebhooklog.FieldTimes)
	}
	if m.request != nil {
		fields = append(fields, servicewebhooklog.FieldRequest)
	}
	if m.resp != nil {
		fields = append(fields, servicewebhooklog.FieldResp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceWebhookLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicewebhooklog.FieldUUID:
		return m.UUID()
	case servicewebhooklog.FieldCreatedAt:
		return m.CreatedAt()
	case servicewebhooklog.FieldUpdatedAt:
		return m.UpdatedAt()
	case servicewebhooklog.FieldDeletedAt:
		return m.DeletedAt()
	case servicewebhooklog.FieldName:
		return m.Name()
	case servicewebhooklog.FieldSid:
		return m.Sid()
	case servicewebhooklog.FieldURL:
		return m.URL()
	case servicewebhooklog.FieldStatusCode:
		return m.StatusCode()
	case servicewebhooklog.FieldTimes:
		return m.Times()
	case servicewebhooklog.FieldRequest:
		return m.Request()
	case servicewebhooklog.FieldResp:
		return m.Resp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceWebhookLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicewebhooklog.FieldUUID:
		return m.OldUUID(ctx)
	case servicewebhooklog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servicewebhooklog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servicewebhooklog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case servicewebhooklog.FieldName:
		return m.OldName(ctx)
	case servicewebhooklog.FieldSid:
		return m.OldSid(ctx)
	case servicewebhooklog.FieldURL:
		return m.OldURL(ctx)
	case servicewebhooklog.FieldStatusCode:
		return m.OldStatusCode(ctx)
	case servicewebhooklog.FieldTimes:
		return m.OldTimes(ctx)
	case servicewebhooklog.FieldRequest:
		return m.OldRequest(ctx)
	case servicewebhooklog.FieldResp:
		return m.OldResp(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceWebhookLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceWebhookLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicewebhooklog.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case servicewebhooklog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servicewebhooklog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servicewebhooklog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case servicewebhooklog.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case servicewebhooklog.FieldSid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSid(v)
		return nil
	case servicewebhooklog.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case servicewebhooklog.FieldStatusCode:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusCode(v)
		return nil
	case servicewebhooklog.FieldTimes:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimes(v)
		return nil
	case servicewebhooklog.FieldRequest:
		v, ok := value.(*schema.WebhookRequest)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequest(v)
		return nil
	case servicewebhooklog.FieldResp:
		v, ok := value.(*schema.WebhookResp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResp(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceWebhookLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceWebhookLogMutation) AddedFields() []string {
	var fields []string
	if m.addstatus_code != nil {
		fields = append(fields, servicewebhooklog.FieldStatusCode)
	}
	if m.addtimes != nil {
		fields = append(fields, servicewebhooklog.FieldTimes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceWebhookLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case servicewebhooklog.FieldStatusCode:
		return m.AddedStatusCode()
	case servicewebhooklog.FieldTimes:
		return m.AddedTimes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceWebhookLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case servicewebhooklog.FieldStatusCode:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusCode(v)
		return nil
	case servicewebhooklog.FieldTimes:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimes(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceWebhookLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceWebhookLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(servicewebhooklog.FieldDeletedAt) {
		fields = append(fields, servicewebhooklog.FieldDeletedAt)
	}
	if m.FieldCleared(servicewebhooklog.FieldStatusCode) {
		fields = append(fields, servicewebhooklog.FieldStatusCode)
	}
	if m.FieldCleared(servicewebhooklog.FieldTimes) {
		fields = append(fields, servicewebhooklog.FieldTimes)
	}
	if m.FieldCleared(servicewebhooklog.FieldRequest) {
		fields = append(fields, servicewebhooklog.FieldRequest)
	}
	if m.FieldCleared(servicewebhooklog.FieldResp) {
		fields = append(fields, servicewebhooklog.FieldResp)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceWebhookLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceWebhookLogMutation) ClearField(name string) error {
	switch name {
	case servicewebhooklog.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case servicewebhooklog.FieldStatusCode:
		m.ClearStatusCode()
		return nil
	case servicewebhooklog.FieldTimes:
		m.ClearTimes()
		return nil
	case servicewebhooklog.FieldRequest:
		m.ClearRequest()
		return nil
	case servicewebhooklog.FieldResp:
		m.ClearResp()
		return nil
	}
	return fmt.Errorf("unknown ServiceWebhookLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceWebhookLogMutation) ResetField(name string) error {
	switch name {
	case servicewebhooklog.FieldUUID:
		m.ResetUUID()
		return nil
	case servicewebhooklog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servicewebhooklog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servicewebhooklog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case servicewebhooklog.FieldName:
		m.ResetName()
		return nil
	case servicewebhooklog.FieldSid:
		m.ResetSid()
		return nil
	case servicewebhooklog.FieldURL:
		m.ResetURL()
		return nil
	case servicewebhooklog.FieldStatusCode:
		m.ResetStatusCode()
		return nil
	case servicewebhooklog.FieldTimes:
		m.ResetTimes()
		return nil
	case servicewebhooklog.FieldRequest:
		m.ResetRequest()
		return nil
	case servicewebhooklog.FieldResp:
		m.ResetResp()
		return nil
	}
	return fmt.Errorf("unknown ServiceWebhookLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceWebhookLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceWebhookLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceWebhookLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceWebhookLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceWebhookLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceWebhookLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceWebhookLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ServiceWebhookLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceWebhookLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ServiceWebhookLog edge %s", name)
}
